<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>JavaScript 精粹 基础 进阶(4)对象</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" type="text/css" href="/assets/css/main.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/public.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/style.css">
	<!-- <link rel="stylesheet" type="text/css" href="/assets/css/pygments.css"> -->
	<link rel="shortcut icon" href="/assets/images/logo_ioc.ico" type="images/x-icon"/>
	<link rel="icon" href="/assets/images/logo_ioc.png" type="images/png"/>
	<script src="http://libs.baidu.com/jquery/1.9.0/jquery.js" type="text/javascript"></script>
	
	<script type="text/javascript">
	    (function($) {

	    	var temp = 0;
	    	$(document).scroll(function() {

	    		if ($(document).scrollTop() > temp) {
	    			$("#header").addClass("hide-top");
	    		} else {
	    			$("#header").removeClass("hide-top");
	    		}
	    		temp = $(document).scrollTop();
	    	});
	    	
	    	//console.log($(".menu"))
	    })(jQuery);

	</script>

</head>
<body>
    <header id="header" role="banner">
	<a id="hgroup" href="/" rel="home">
		<h1 id="logo"></h1>
		<i class="slogan" title="返回首页">
			热爱编程，关注前端开发技术
		</i>
	</a>
	<div class="connect">
		<a href="https://github.com/huanghanzhilian" class="git" target="_blank"></a>
		<a href="http://www.huanghanlian.com/feed.xml" class="rss"></a>
	</div>
	<nav id="nav">
		<ul class="menu">
			<li class="menu_item">
				<a href="/">首页</a>
			</li>
			<li class="menu_item">
				<a href="http://www.huanghanlian.com/widget/">Web组件库</a>
			</li>
			<li class="menu_item">
				<a href="http://www.huanghanlian.com/front-end-note/">前端笔记</a>
			</li>
			<li class="menu_item">
				<a href="/about/">关于本站</a>
			</li>
			<li class="menu_item">
				<a href="/report/">留言板</a>
			</li>
		</ul>
	</nav>

	<div id="m-btns">
		<div class="menu"></div>
	</div>
	<nav class="nav-bar-tabs ">
		<ul>
            <li>
              	<a href="/">首页</a>
            </li>
            <li>
              	<a href="http://www.huanghanlian.com/widget/">Web组件库</a>
            </li>
            <li>
              	<a href="http://www.huanghanlian.com/front-end-note/">前端笔记</a>
            </li>
            <li>
              	<a href="/about/">关于本站</a>
            </li>
            <li>
              	<a href="/report/">留言板</a>
            </li>
        </ul>
	</nav>
</header>
	<div id="container" class="clearfix">
	<main id="main" class="hfeed">
		<article id="post-157" class="post-157 hentry">
			<header class="entry-header">
				<h1 class="entry-title">JavaScript 精粹 基础 进阶(4)对象</h1>
				<div class="entry-meta">2016-12-20 <span class="dot">•</span>JavaScript<span class="dot">•</span>黄继鹏<span id="busuanzi_container_page_pv">  |  阅读量 <span id="busuanzi_value_page_pv"></span> 次</span></div>
			</header>
			<article class="post-content">
              <p>对象中包含一系列属性，这些属性是无序的。每个属性都有一个字符串key和对应的value。</p>

<h3>JavaScript 对象概述</h3>

<blockquote>
<p>概述</p>
</blockquote>

<p><strong>对象中包含一系列属性，这些属性是无序的。每个属性都有一个字符串key和对应的value。</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {x : 1, y : 2};    //定义obj对象， 有两个属性x和y
obj.x; // 1   //访问对应obj.x属性取到对应的值
obj.y; // 2   //访问对应obj.y属性取到对应的值
</code></pre></div>
<p>这里有两个重点，一个是属性是无序的，再一个每一个<code>key</code>是字符串。</p>

<blockquote>
<p>探索对象的key</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {};    //定义对象obj
obj[1] = 1;      //动态赋值数字1属性值为1
obj['1'] = 2;    //动态赋值字符串1属性值为2
console.log(obj); // Object {1: 2}  //实际上结果指向的是同一个属性

//每个属性都有一个字符串key和对应的value。

obj[{}] = true;    //[{}] 空对象作为key
obj[{x : 1}] = true;     //对象带有属性的对象作为key  //js都会把它转换成字符串然后再去处理，最终指向的是同一个属性
console.log(obj)// Object {1: 2, [object Object]: true}
</code></pre></div>
<blockquote>
<p>回顾-数据类型</p>
</blockquote>

<p><img src="http://upload-images.jianshu.io/upload_images/3877962-cf48b65c7a5c38b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<p>函数，数组，日期，正则等都是对象</p>

<blockquote>
<p>对象结构</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {};    //字面量空对象
obj.y = 2;       //赋值创建属性x
obj.x = 1;       //赋值创建属性y
</code></pre></div>
<p>对象有个特点，他的属性可以动态的添加或删除的</p>

<p><strong>函数对象</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">function foo(){};
console.log(foo.prototype);
</code></pre></div>
<p><img src="http://upload-images.jianshu.io/upload_images/3877962-0927720a486ccd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<p>创建一个函数声明<br>
每一个函数都会有一个<code>foo.prototype</code>对象属性</p>
<div class="highlight"><pre><code class="language-" data-lang="">function foo(){};
foo.prototype.z=1;
console.log(foo.prototype);
</code></pre></div>
<p><img src="http://upload-images.jianshu.io/upload_images/3877962-801d690e9bac45d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<p>给<code>foo.prototype</code>对象属性添加属性<code>z</code>赋值为1，<code>foo.prototype</code>对象属性下有个<code>constructor</code>属性方法，该属性其实是指向自己本身。</p>
<div class="highlight"><pre><code class="language-" data-lang="">function foo(){};
foo.prototype.z=1;
console.log(foo.prototype);

var obj =new foo();
console.log(obj);
</code></pre></div>
<p><img src="http://upload-images.jianshu.io/upload_images/3877962-3c12980454ffbf3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<p>通过<code>new</code>去实例化<code>foo()</code>函数<code>var obj =new foo();</code>那么这个<code>obj</code>原型就会指向构造器的<code>prototype</code>属性也就是<code>foo.prototype</code>，可以通过上图看出打印输出是一样的。</p>

<h3>JavaScript 创建对象，原型链</h3>

<blockquote>
<p>对象创建-字面量</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var obj1 = {x : 1, y : 2};
</code></pre></div>
<p>对象字面量 ，用{}设置属性</p>
<div class="highlight"><pre><code class="language-" data-lang="">var obj2 = {
    x : 1,
    y : 2,
    o : {
        z : 3,
        n : 4
    }
};
</code></pre></div>
<p>对象字面量也可以做一些嵌套，比如某些属性值可以又是对象</p>

<blockquote>
<p>创建对象-new/原型链</p>
</blockquote>

<p>还有一种就是使用<code>new</code>构造器的方法创建对象，先来了解javascript中的原型链。</p>

<p>什么是原型链</p>
<div class="highlight"><pre><code class="language-" data-lang="">function foo(){}    //定义函数对象  
foo.prototype.z = 3;      //函数对象默认带foo.prototype对象属性  对象添加z属性=3

var obj =new foo();    //用构造器方式构造新的对象
obj.y = 2;    //通过赋值添加2个属性给obj
obj.x = 1;   //通过new去构造这样一个对象他的主要特点是，他的原型会指向构造器的foo.prototype属性

obj.x; // 1  //访问obj.x发现对象上有x返回1
obj.y; // 2  //访问obj.y发现对象上有x返回2
obj.z; // 3  //obj上没有z并不会停止查找，会去查找他的原型foo.prototype.z返回3
typeof obj.toString; // ‘function'  这是一个函数，toString是Object.prototype上面的每个对象都有
'z' in obj; // true     obj.z是从foo.prototype继承而来的，所以说obj里面有z
obj.hasOwnProperty('z'); // false   表示z并不是obj直接对象上的，而是对象原型链上的。
</code></pre></div>
<p>但是如果是赋值的话结果就一样了。</p>

<p>比如我们赋值<code>obj.z=5</code></p>

<p>如果给<code>obj.z</code>尝试去赋值，就不会像原型链上去查找了。先看<code>obj.z</code>有没有，有的话修改它的值，没有的话，在对象上添加<code>obj.z</code>。</p>

<p><img src="http://upload-images.jianshu.io/upload_images/3877962-5279a12733aad48b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<div class="highlight"><pre><code class="language-" data-lang="">obj.z = 5;
obj.hasOwnProperty('z'); // true
foo.prototype.z; // still 3
obj.z; // 5

obj.z = undefined;
obj.z; // undefined
</code></pre></div>
<p>那么怎样能拿到原型链上的z呢</p>
<div class="highlight"><pre><code class="language-" data-lang="">delete obj.z; // true  删除对象上的z属性
obj.z; // 3  //这样就能获取原型链上的z
</code></pre></div>
<blockquote>
<p>对象创建-Object.create</p>
</blockquote>

<p>从字面量理解是对象创建</p>

<p><code>Object.create({x:1});</code>是系统内置的函数，这个函数会接收一个参数，一般是一个对象。他会返回一个新创建的对象，并且让这个对象的原型指向参数，参数一般是个对象。</p>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = Object.create({
    x: 1
});
console.log(obj.x) // 1
console.log(typeof obj.toString) // "function"
console.log(obj.hasOwnProperty('x')); // false
console.dir(obj)
</code></pre></div>
<p><img src="http://upload-images.jianshu.io/upload_images/3877962-dff2f50d6c39b7c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<h3>JavaScript 属性操作</h3>

<blockquote>
<p>读写对象属性</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {
    x: 1,
    y: 2
};
console.log(obj.x); // 1
console.log(obj["y"]); // 2

obj["x"] = 3;
obj.y = 4;
</code></pre></div>
<p>创建对象字面量<code>obj</code>，有<code>x</code>和<code>y</code>两个属性，可以用<code>obj.y</code>(点)操作符去访问他的属性，也可以用<code>obj[&quot;y&quot;]</code>[中括号这里需要是字符串]</p>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {
    x1: 1,
    x2: 2
};
var i = 1,
    n = 2;

for (; i &lt;= n; i++) {
    console.log(obj['x' + i]);
}
// 输出: 1, 2
</code></pre></div>
<p>obj[&#39;x&#39;]使用方法，obj[&#39;x&#39;]同等于obj.x。obj[&#39;x&#39;]可以在[]内拼接字符串，obj.x+&quot;&quot;不是那么方便</p>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {
    x1: 1,
    x2: 2
};
var p;
for (p in obj) {
    console.log(obj[p]);
}
</code></pre></div>
<p>用for...in遍历所有属性<br>
需要注意的是<code>用for...in</code>去遍历的话，有可能把原型链上的属性也遍历出来，并且他的顺序是不确定的。</p>

<blockquote>
<p>属性读写-异常</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {
    x: 1
};//创建对象obj
console.log(obj.y); //如果访问一个不存在的属性会进行原型链查找如果找到末端还是找不到就会返回 undefined
var yz = obj.y.z; //不能获取undefined的属性z   TypeError: Cannot read property 'z' of undefined
obj.y.z = 2; //不能给undefined的属性z去赋值 TypeError: Cannot set property 'z' of undefined



var yz;
if (obj.y) {
    yz = obj.y.z;
}//判断当obj.y存在把他取出来


//巧用运算符
var yz = obj &amp;&amp; obj.y &amp;&amp; obj.y.z;
</code></pre></div>
<blockquote>
<p>属性删除</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var person = {
    age: 28,
    title: 'fe'
};
delete person.age; // true  表示删除成功
delete person['title']; // true  表示删除成功
person.age; // undefined
delete person.age; // true

delete Object.prototype; // false,  不允许删除

//通过getOwnPropertyDescriptor方法去获取一个属性中所有的标签，第一个参数是你要查看的对象，第二个是你要去检测的属性这样就能拿到属性的描述器
var descriptor = Object.getOwnPropertyDescriptor(Object, 'prototype');
console.log(descriptor);
</code></pre></div>
<blockquote>
<p>属性检测</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var cat = new Object;  //使用new 构造对象
cat.legs = 4;    //赋值属性legs值为4
cat.name = "Kitty";  //赋值属性name值为Kitty

'legs' in cat; // true   表示cat中有legs属性 in操作符是会向原型链上查找的
'abc' in cat; // false   表示cat中没有abc属性
"toString" in cat; // true, 继承 property有toString属性

cat.hasOwnProperty('legs'); // true   表示cat直接量属性有legs
cat.hasOwnProperty('toString'); // false   表示cat直接量属性没有toString   toString是在原型有

cat.propertyIsEnumerable('legs'); // true  legs可枚举  查看是否可枚举propertyIsEnumerable   for...in会被循环
cat.propertyIsEnumerable('toString'); // false   toString不可枚举  查看是否可枚举propertyIsEnumerable   for...in不会被循环
</code></pre></div>
<p><strong>自定义对象属性，让他的枚举标签是false</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">var cat = new Object;  //使用new 构造对象
cat.legs = 4;    //赋值属性legs值为4
cat.name = "Kitty";  //赋值属性name值为Kitty

'legs' in cat; // true   表示cat中有legs属性 in操作符是会向原型链上查找的
'abc' in cat; // false   表示cat中没有abc属性
"toString" in cat; // true, 继承 property有toString属性

cat.hasOwnProperty('legs'); // true   表示cat直接量属性有legs
cat.hasOwnProperty('toString'); // false   表示cat直接量属性没有toString   toString是在原型有

cat.propertyIsEnumerable('legs'); // true  legs可枚举  查看是否可枚举propertyIsEnumerable   for...in会被循环
cat.propertyIsEnumerable('toString'); // false   toString不可枚举  查看是否可枚举propertyIsEnumerable   for...in不会被循环

//通过Object.defineProperty给cat目标对象去添加一个属性price
//enumerable:是否能在for...in循环中遍历出来或在Object.keys中列举出来。
//value:属性的值给属性赋值
Object.defineProperty(cat, 'price', {enumerable: false, value: 1000});
cat.propertyIsEnumerable('price'); // false  price不可枚举  查看是否可枚举propertyIsEnumerable   for...in不会被循环
cat.hasOwnProperty('price'); // true   表示cat直接量属性有price
console.log(cat)
for(var k in cat){
    console.log(cat[k]);//循环出来看看能不能被枚举
}
</code></pre></div>
<p><strong>判断对象属性是否存在进行操作</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">if (cat &amp;&amp; cat.legs) {
    cat.legs *= 2;
}//8
</code></pre></div>
<p>判断<code>cat</code>是否存在且<code>cat.legs</code>不是<code>undefined</code>的时候，让<code>cat.legs</code>值乘等于2，表示<code>cat.legs</code>乘以2再赋值给<code>cat.legs</code></p>
<div class="highlight"><pre><code class="language-" data-lang="">if (cat.legs !== undefined) {
    // only if cat.legs is not undefined
}
</code></pre></div>
<p>判断<code>cat.legs</code>不等于<code>undefined</code>的时候去做动作</p>
<div class="highlight"><pre><code class="language-" data-lang="">if (cat.legs !== undefined) {
    // only if cat.legs is not undefined
}
</code></pre></div>
<p>判断<code>cat.legs</code>严格不等于<code>undefined</code>的时候去做动作</p>

<blockquote>
<p>属性枚举</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var o = {
    x: 1,
    y: 2,
    z: 3
};
'toString' in o; // true
o.propertyIsEnumerable('toString'); // false
var key;
for (key in o) {
    console.log(key); // x, y, z
}
</code></pre></div>
<p>这样写出来的对象原型链属性默认是不可枚举的，所以<code>for....in</code>的时候原型链不会出来。</p>
<div class="highlight"><pre><code class="language-" data-lang="">var o = {
    x: 1,
    y: 2,
    z: 3
};
var obj = Object.create(o);  //创建obj对象以o对象作为原型
obj.a = 4;

console.log(obj)
var key;
for (key in obj) {
    console.log(key); // a, x, y, z
}
</code></pre></div>
<p>创建<code>obj</code>对象以<code>o</code>对象作为原型
所有对象上的属性，和原型上的属性都会遍历中显示出来</p>

<p><strong>那有时候我只想处理对象上的属性，不想遍历我对象原型链上的属性。</strong></p>

<p>我们需要在加一个<code>obj.hasOwnProperty(key)</code>的判断，来过滤掉原型链上的属性就可以了。</p>
<div class="highlight"><pre><code class="language-" data-lang="">var o = {
    x: 1,
    y: 2,
    z: 3
};
var obj = Object.create(o);  //创建obj对象以o对象作为原型
obj.a = 4;

var key;
for (key in obj) {
    if (obj.hasOwnProperty(key)){
        console.log(key); // a
    }
}
</code></pre></div>
<blockquote>
<p>JavaScript get/set方法</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var man = {
    name: 'huang',
    weibo: '@.com',
    get age() {
        return new Date().getFullYear() - 1993;
    },
    set age(val) {
        console.log('年龄不能设置' + val);
    }
}
console.log(man.age); //23
man.age = 100; //年龄不能设置100
console.log(man.age); //23
</code></pre></div>
<p>定义了一个对象<code>man</code>有属性<code>name</code>值是<code>huang</code>，这里定义了一对<code>get</code>和<code>set</code>方法，来去访问属性<code>age</code></p>

<p>语法</p>

<p>用<code>get</code>或<code>set</code>关键字开头，空格，然后是属性的名字，然后是括号再方括号，里面是一个函数体，</p>

<p><code>get</code>方法会返回当前日期的年份减去我的出生日，会拿到我的年龄。</p>

<p><code>set</code>方法会拿到括号赋值的值，唯一的参数创进来。</p>

<p>当访问<code>console.log(man.age); //23</code>会返回<code>get</code>方法，</p>

<p>当使用<code>man.age = 100;</code>也就是说给<code>set</code>去赋值的时候，就会去调用<code>set</code>方法，就会输出<code>年龄不能设置100</code></p>

<p>再去输出<code>console.log(man.age); //23</code>会发现仍然是23，因为<code>set</code>没做任何的事情。</p>
<div class="highlight"><pre><code class="language-" data-lang="">var man = {
    name: 'huang',
    $age: null,
    get age() {
        if (this.$age == undefined) {
            return new Date().getFullYear() - 1993;
        } else {
            return this.$age;
        }
    },
    set age(val) {
        val = +val;
        if (!isNaN(val) &amp;&amp; val &gt; 0 &amp;&amp; val &lt; 150) {
            this.$age = +val;
        } else {
            throw new Error('Incorrect=' + val);
        }
    }
}
console.log(man.age); //23
man.age = 100;
console.log(man.age); //100
man.age = 'abn';
console.log(man.age);//Uncaught Error: Incorrect=NaN(…)
</code></pre></div>
<blockquote>
<p>get/set与原型链</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">function foo() {};

Object.defineProperty(foo.prototype, 'z', {
    get: function() {
        return 1;
    }
});

var obj = new foo();

console.log(obj.z); //1
obj.z = 10;
console.log(obj.z); //还是输出1

Object.defineProperty(obj, 'z', {
    value: 100,
    configurable: true
});

console.log(obj.z);//100
delete obj.z;
console.log(obj.z);//1
</code></pre></div>
<p>解释</p>
<div class="highlight"><pre><code class="language-" data-lang="">function foo() {};
</code></pre></div>
<p>创建一个<code>foo函数</code>，就会有一个<code>foo.prototype</code></p>

<p><img src="http://upload-images.jianshu.io/upload_images/3877962-c0c316829ee86954.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<div class="highlight"><pre><code class="language-" data-lang="">Object.defineProperty(foo.prototype, 'z', {
    get: function() {
        return 1;
    }
});
</code></pre></div>
<p>通过<code>defineProperty</code>用<code>git</code>方法来创建<code>z属性</code>，<code>git</code>方法只是固定的返回1。</p>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = new foo();
</code></pre></div>
<p>使用<code>new</code>方式来创建一个新的对象<code>obj</code>，这样这个<code>obj</code>对象的原型会指向<code>foo.prototype</code></p>
<div class="highlight"><pre><code class="language-" data-lang="">console.log(obj.z); //1
</code></pre></div>
<p>当我们去访问<code>obj.z</code>的时候<code>obj</code>对象上没有<code>z直接量属性</code>，所以他会向上去查找，<code>foo.prototype</code>原型，发现有一个<code>z属性</code>用的是<code>get</code>方法，这样就能返回1，</p>
<div class="highlight"><pre><code class="language-" data-lang="">obj.z = 10;
console.log(obj.z); //还是输出1
</code></pre></div>
<p>那么我赋值，尝试给<code>z</code>赋值为10，如果z不是用get方式赋值的是通过<code>foo.prototype.z</code>原型赋值的话，再使用直接量去赋值是可以成功的，值会返回到<code>obj</code>这个对象上，但是在这里赋值并没有成功。仍然返回1。</p>

<p>这是因为当<code>obj</code>对象上没有z直接量属性的时候，并且他的原型链查找发现有<code>get</code>和<code>set</code>方法的时候，那么当我们尝试去赋值的时候，实际上会走原型上<code>get</code>和<code>set</code>方法的，而不会再去通过给当前对象<code>obj</code>添加新属性。</p>
<div class="highlight"><pre><code class="language-" data-lang="">Object.defineProperty(obj, 'z', {
    value: 100,
    configurable: true
});
</code></pre></div>
<p>通过<code>Object.defineProperty</code>给<code>obj</code>目标对象去添加一个属性<code>z</code></p>

<ul>
<li>value:属性的值给属性赋值</li>
<li>writable:如果为false，属性的值就不能被重写。</li>
<li>get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。</li>
<li>set:一旦目标属性被赋值，就会调回此方法。</li>
<li>configurable:如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化。</li>
<li><p>enumerable:是否能在for...in循环中遍历出来或在Object.keys中列举出来。</p>

<p>console.log(obj.z);//100</p></li>
</ul>

<p>这个时候obj.z是<code>obj</code>的直接量返回100</p>
<div class="highlight"><pre><code class="language-" data-lang="">delete obj.z;
</code></pre></div>
<p>由于<code>configurable: true</code>所以删除是成功的</p>
<div class="highlight"><pre><code class="language-" data-lang="">console.log(obj.z);//1
</code></pre></div>
<p>这里因为直接量z被删除们说以他会继续去向上查找<code>z</code>的<code>get</code>方法。</p>

<p>小案例</p>
<div class="highlight"><pre><code class="language-" data-lang="">var o={z:2};
Object.defineProperty(o,'x',{value:1});//默认writable=false只读,configurable=false不可写
o.z=6;
o.x=6;
console.log(o);
</code></pre></div>
<p><img src="http://upload-images.jianshu.io/upload_images/3877962-e7b028717c1bb4ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<p>案例解释</p>
<div class="highlight"><pre><code class="language-" data-lang="">var o={};
Object.defineProperty(o,'x',{value:1});//默认writable=false只读,configurable=false不可写
var obj=Object.create(o);//创建obj对象以o对象作为原型
console.log(obj.x);//1   会向上查找返回原型链x属性值1
obj.x=200; //尝试去赋值200
console.log(obj.x);//赋值后打印任然是1

//那么如何去在obj对象添加x属性呢？

//还是要用Object.defineProperty


//给obj对象添加一个自己的属性x，这样就可以覆盖掉原型链上的不可写的x，writable:true,configurable:true,value:100
Object.defineProperty(obj,'x',{writable:true,configurable:true,value:100});
console.log(obj.x);//100   obj.x是直接量属性
obj.x=500;   //直接量属性可以赋值
console.log(obj.x);//500   //修改成功
</code></pre></div>
<h3>JavaScropt属性标签</h3>

<blockquote>
<p>属性标签</p>
</blockquote>

<p><strong>怎样去看某一个对象上的属性上都有哪些标签</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">console.log(Object.getOwnPropertyDescriptor({pro:true}, 'pro'));检查一个字面量的对象，添加属性`pro:true`看字面量下的属性`pro`的属性标签
//configurable:true,enumerable:true,value:true,writable:true
console.log(Object.getOwnPropertyDescriptor({pro:true}, 'a'));//去查一个根本不存在的属性返回undefined
//undefined
</code></pre></div>
<p>通过<code>Object.getOwnPropertyDescriptor(参数1,&quot;参数2&quot;)</code>方法可以返回一个对象，这个对象上会显示 当前这个属性下所有的标签，这个函数会接收两个参数，第一个是你要去判断的对象，第二个是一个字符串的属性名，</p>

<ul>
<li>value:属性的值给属性赋值</li>
<li>writable:如果为false，属性的值就不能被重写。</li>
<li>get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。</li>
<li>set:一旦目标属性被赋值，就会调回此方法。</li>
<li>configurable:如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化。</li>
<li><p>enumerable:是否能在for...in循环中遍历出来或在Object.keys中列举出来</p>

<p>console.log(Object.getOwnPropertyDescriptor({pro:true}, &#39;pro&#39;));检查一个字面量的对象，添加属性<code>pro:true</code>看字面量下的属性<code>pro</code>的属性标签</p></li>
</ul>

<p>得到的结果是</p>
<div class="highlight"><pre><code class="language-" data-lang="">//configurable:true,enumerable:true,value:true,writable:true
</code></pre></div>
<p><strong>那么怎么去设置或者说设置对象的属性标签呢？</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">var person = {};
Object.defineProperty(person, 'name', {
    configurable: false,
    writable: false,
    enumerable: false,
    value: "继小鹏"
});
console.log(person.name); //继小鹏
person.price = 100; //修改不了
console.log(person.name); //还是继小鹏
console.log(delete person.name); //false  不可删除
</code></pre></div>
<p>解释例子</p>

<p>创建一个空对象</p>
<div class="highlight"><pre><code class="language-" data-lang="">var person = {};
</code></pre></div>
<p>通过<code>Object.defineProperty(参数1,&quot;参数2&quot;,{参数1})</code>第一个参数是要添加属性的对象，第二个参数是一个字符串属性的名字，第三个参数是一个对象，这个对象里面就是具体每一个标签的值，</p>
<div class="highlight"><pre><code class="language-" data-lang="">Object.defineProperty(person, 'name', {
    configurable: false,//不可删除
    writable: false,//属性的值就不能被重写。
    enumerable: true,//可枚举
    value: "继小鹏"//属性的值给属性赋值
});
</code></pre></div>
<p>结果符合预期</p>
<div class="highlight"><pre><code class="language-" data-lang="">console.log(person.name); //继小鹏
person.price = 100; //修改不了
console.log(person.name); //还是继小鹏
console.log(delete person.name); //false  不可删除
</code></pre></div>
<p><strong>创建新的属性使用<code>Object.keys</code></strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">var person = {};
Object.defineProperty(person, 'name', {
    configurable: false,
    writable: false,
    enumerable: true,
    value: "继小鹏"
});

Object.defineProperty(person, 'type', {
    configurable: true,
    writable: true,
    enumerable: false,
    value: "继小鹏222"
});


console.log(person);

console.log(Object.keys(person));
</code></pre></div>
<p><img src="http://upload-images.jianshu.io/upload_images/3877962-8f3025f5cc6a3d15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<p>新创建的属性<code>enumerable: false,</code>不可枚举，可以通过<code>Object.keys(person)</code>的方法来去获取对象上所有的<code>key</code>
因为新创建的属性<code>enumerable: false,</code>不可枚举所有不可见。</p>

<p><strong>使用Object.defineProperties()定义多个对象属性标签</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">Object.defineProperties(person, {
    title: {
        value: 'fe',
        enumerable: true,
    },
    corp: {
        value: 'SDF',
        enumerable: true,
    },
    salary: {
        value: '50000',
        enumerable: true,
        writable: true
    }
});


console.log(person);
console.log(Object.getOwnPropertyDescriptor(person, 'corp'));
console.log(Object.getOwnPropertyDescriptor(person, 'salary'));
</code></pre></div>
<p><img src="http://upload-images.jianshu.io/upload_images/3877962-97898b59fe919abb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<p><code>Object.defineProperties()</code>这个函数接收两个参数，第一个参数是你要定义属性的对象，第二个参数是一个对象，对象里包含属性值列表集。</p>

<p><strong>例子</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">var person = {};
Object.defineProperties(person, {
    title: {
        value: 'fe',
        enumerable: true,
    },
    corp: {
        value: 'SDF',
        enumerable: true,
    },
    salary: {
        value: '50000',
        enumerable: true,
        writable: true
    },
    luck: {
        get: function() {
            return Math.random() &gt; 0.5 ? 'good' : 'bad';
        }
    },
    promote: {
        set: function(level) {
            this.salary *= 1 + level * 0.1;
        }
    }
});



console.log(Object.getOwnPropertyDescriptor(person, 'salary'));
console.log(Object.getOwnPropertyDescriptor(person, 'corp'));
console.log(person.salary);
person.promote = 3;
console.log(person.salary);
console.log(person.luck);
</code></pre></div>
<p><img src="http://upload-images.jianshu.io/upload_images/3877962-8fe3925d20d034aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>

<h3>JavaScropt对象标签、对象序列化</h3>

<blockquote>
<p>对象标签</p>
</blockquote>

<p>对象级别也是有标签的，主要有三种</p>

<ol>
<li><p>[[proto]]</p></li>
<li><p>[[class]]</p></li>
<li><p>[[extensible]]</p></li>
</ol>

<blockquote>
<p>原型标签<code>__proto__</code></p>
</blockquote>

<p><code>__proto__</code>实际上就是原型，比如说当我们用<code>new</code>构造器的方式去实例化函数对象，那么这个实例化对象的原型链会指向构造器的<code>prototype</code>，一般的对象也会有原型，指向 <code>Object.prototype</code>然后在往上就是<code>nall</code>。</p>

<blockquote>
<p>class标签</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var toString = Object.prototype.toString;

function getType(o) {
    return toString.call(o).slice(8, -1);
};

console.log(toString.call(null)); //[object Null]

console.log(getType(null)); //Null
console.log(getType(undefined)); //Undefined
console.log(getType(1)); //Number
console.log(getType(new Number(1))); //Number
console.log(typeof new Number(1)); //object
console.log(getType(true)); //Boolean
console.log(getType(new Boolean(true))); //Boolean
</code></pre></div>
<p>class标签是没有一个直接的方式去查看他或者是修改他，可以间接的通过<code>Object.prototype.toString;</code>的方式来去获取class，</p>
<div class="highlight"><pre><code class="language-" data-lang="">var toString = Object.prototype.toString;
</code></pre></div>
<p>先把<code>Object.prototype.toString;</code>这样一个函数拿到，赋值给<code>toString</code>这样方便后面代码简短一些，</p>
<div class="highlight"><pre><code class="language-" data-lang="">function getType(o) {
    return toString.call(o).slice(8, -1);
};
</code></pre></div>
<p>定义一个方法，返回<code>toString.call(o)</code> 来调用这个函数方法，并且把参数<code>o</code>作为<code>this</code>传进去，然后用<code>slice(8, -1);</code>表示是截取从第八个字符开始，一直到最后。</p>

<p>调用<code>getType(1); //Number</code>getType(1)方法会返回类型。</p>

<blockquote>
<p>extensible标签</p>
</blockquote>

<p>extensible标签表示你这个对象是否可扩展，言外之意就是说对象上的属性是否可以被继续添加。</p>
<div class="highlight"><pre><code class="language-" data-lang="">var obj={x:1,y:2};//创建对象
Object.isExtensible(obj);//true
</code></pre></div>
<p>创建对象obj，通过<code>Object.isExtensible(obj);</code>来判断对象是否可扩展，一般情况下默认返回true。表示可以扩展。</p>

<p><strong>那么怎么样不让他扩展，不可修改不可删除冻结对象</strong></p>
<div class="highlight"><pre><code class="language-" data-lang="">var obj={x:1,y:2};//创建对象
Object.isExtensible(obj);//true   obj对象可扩展

Object.preventExtensions(obj);    //设置obj对象不可扩展
Object.isExtensible(obj);//false   obj对象不可扩展
obj.d=2;   //尝试给obj添加新的属性会发现添加失败
console.log(obj.d);//undefined

//如果已经组织对象可扩展，那么对象上的属性标签是否会发生变化呢？

console.log(Object.getOwnPropertyDescriptor(obj, 'x'));
//value: 1, writable: true, enumerable: true, configurable: true
//虽然我们阻止了对象不可添加新属性，但是已有熟悉仍然可以修改和删除，也是可以枚举的。

//可以通过
Object.seal(obj);//会把对象上的属性的configurable设置为false不可删除
console.log(Object.getOwnPropertyDescriptor(obj, 'x'));
//value: 1, writable: true, enumerable: true, configurable: false
console.log(Object.isSealed(obj));//true   判断对象是否被隐藏不可删除


Object.freeze(obj);//让对象冻结不可写
console.log(Object.getOwnPropertyDescriptor(obj, 'x'));
//value: 1, writable: false, enumerable: true, configurable: false
console.log(Object.isFrozen(obj));//true   判断对象是否被不可写
</code></pre></div>
<blockquote>
<p>序列化</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {
    x: 1,
    y: true,
    z: [1, 2, 3],
    nullval: null
};
console.log(obj);
console.log(JSON.stringify(obj)); //{"x":1,"y":true,"z":[1,2,3],"nullval":null}
var obj1 = {
    val: undefined,
    a: NaN,
    b: Infinity,
    c: Date()
};
console.log(obj1);
console.log(JSON.stringify(obj1)); //{"a":null,"b":null,"c":"Fri Dec 16 2016 22:25:04 GMT+0800 (中国标准时间)"}

var obj2 = JSON.parse('{"x":1}');
console.log(obj2); //Object {x: 1}
console.log(obj2.x); //1
</code></pre></div>
<p>定义obj 字面量对象，有一些属性，通过<code>JSON.stringify(obj));</code>方法返回一个字符串<code>{&quot;x&quot;:1,&quot;y&quot;:true,&quot;z&quot;:[1,2,3],&quot;nullval&quot;:null}</code>返回的字符串就是这个对象的序列化的结果。</p>

<p>需要注意一点这个序列化是有一些坑的，如果你的属性值是<code>undefined</code>的话，那么就不会出现在序列化的结果当中。</p>

<p>如果后端返回一个JSON数据我们怎么把他转换成js对象呢？</p>

<p>使用<code>JSON.parse(&#39;{&quot;x&quot;:1}&#39;);</code>方法，需要注意的是合法的json属性必须以双引号引起来。</p>

<blockquote>
<p>序列化-自定义</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {
    x: 1,
    y: 2,
    o: {
        o1: 1,
        o2: 2,
        toJSON: function() {
            return this.o1 + this.o2;
        }
    }
};

console.log(JSON.stringify(obj)); //{"x":1,"y":2,"o":3}
</code></pre></div>
<p>obj对象下有个属性o他的值是一个对象，那么这个对象序列化的结果我可能想要自定义，那么我们只需要在这个当前的层级下写一个<code>toJSON</code>他的值是一个函数，<code>toJSON</code>是固定这个key一定要这样写，然后这个函数会返回<code>return this.o1 + this.o2;</code>这个this会指向当前层级的数也就是o，</p>

<p>这时候去<code>JSON.stringify(obj));</code>的时候，这里面的o通过<code>toJSON</code>这样一个方法来去返回的。</p>

<blockquote>
<p>其他对象方法</p>
</blockquote>
<div class="highlight"><pre><code class="language-" data-lang="">var obj = {   //定义对象obj
    x: 1,
    y: 2
};
obj.toString(); //"[object Object]"   调用对象的toString方法会返回"[object Object]"这样的字符串实际上没有太大意义

//定义自己对象上个的toString方法
obj.toString = function() {
    return this.x + this.y;    //返回对象的x和y相加作为结果
}

"Result" + obj; //"Result3"   左边是字符串这样会理解为字符串拼接那么他就会调用obj.toString所以返回结果"Result3"
+ obj; //3  用一员加号操作符是可以把对象尝试转换为数字的，如果定义了obj.toString也会去调用obj.toString返回3

//valueOf是尝试把对象转换为基本类型的时候会自动去调用的一个函数，这里自定义返回值
obj.valueOf = function() {
    return this.x + this.y + 100;
} + obj; //103   再去用一员加号操作符把他转换为数字这次返回的结果是103是从这个valueOf而来的
"Result" + obj; //"Result103"
</code></pre></div>
<p>需要主要的是这里面valueOf和toString都存在的时候那么不管是一元的加号还是2元的字符串拼接在做具体操作时，都会尝试把对象转换为基本类型，那么他会先去找valueOf。如果valueOf返回的是基本类型那么就以valueOf的值作为结果反之如果valueOf不存在或者返回的是对象，那么就会去找toString。如果valueOf和toString都没有或者都返回的对象，那么就会报错。</p>

              <!-- 多说评论框 start -->
              		<!-- <span class="ds-thread-count" data-thread-key="/javascript/2016/12/20/javascript_jinjie4" data-count-type="comments"></span> -->
					<div class="ds-thread" data-thread-key="http://www.huanghanlian.com/javascript/2016/12/20/javascript_jinjie4" data-title="JavaScript 精粹 基础 进阶(4)对象" data-url="http://www.huanghanlian.com/javascript/2016/12/20/javascript_jinjie4"></div>
				<!-- 多说评论框 end -->
				<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
				<script type="text/javascript">
				var duoshuoQuery = {short_name:"huanghuanlian"};
					(function() {
						var ds = document.createElement('script');
						ds.type = 'text/javascript';ds.async = true;
						ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
						ds.charset = 'UTF-8';
						(document.getElementsByTagName('head')[0]
						 || document.getElementsByTagName('body')[0]).appendChild(ds);
					})();
				</script>
				<!-- 多说公共JS代码 end -->


				
            </article>
		</article>

	</main>
	<div class="sidebar" id="sidebar">
	<div class="sidebar-top">
		<aside class="widjhuh">
			<h3 class="widget-title">最新文章</h3>
			<ul class="minty_thumblist">
				
                  <li>
                    <a href="/nodejs/2017/04/15/nodejs-one-13.html">

                    	<span>Node.js-HTTP 性能测试</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/nodejs/2017/04/13/nodejs-one-12.html">

                    	<span>Node.js-源码解读之先了解作用域、上下文</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/nodejs/2017/04/08/nodejs-one-11.html">

                    	<span>Node.js-HTTP 事件回调进阶</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/nodejs/2017/04/08/nodejs-one-10.html">

                    	<span>Node.js-HTTP知识先填坑</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/nodejs/2017/04/05/nodejs-one-9.html">

                    	<span>Node.js-URL网址解析的好帮手</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/nodejs/2017/03/27/nodejs-one-8.html">

                    	<span>简单的Nodejs模块</span>
                    </a>
                  </li>
				
			</ul>
		</aside>
	</div>

	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">最近访客</h3>
			<ul class="minty_thumblist minty_thumblist_a ds-recent-visitors visitorsopi" data-num-items="20" data-avatar-size="38">

			</ul>

		    <!--多说js加载开始，一个页面只需要加载一次 -->
		    <script type="text/javascript">
		    var duoshuoQuery = {short_name:"huanghuanlian"};
		    (function() {
		        var ds = document.createElement('script');
		        ds.type = 'text/javascript';ds.async = true;
		        ds.src = 'http://static.duoshuo.com/embed.js';
		        ds.charset = 'UTF-8';
		        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
		    })();
		    </script>
		    <!--多说js加载结束，一个页面只需要加载一次 -->

		</aside>
	</div>

	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">分类目录</h3>
			<ul class="minty_thumblist minty_thumblist_a">
				
				<li>
					<a href="/categories/Markdown/" title="view all
posts">
						Markdown (2)
					</a>
				</li>
				
				<li>
					<a href="/categories/Canvas/" title="view all
posts">
						Canvas (1)
					</a>
				</li>
				
				<li>
					<a href="/categories/Git/" title="view all
posts">
						Git (1)
					</a>
				</li>
				
				<li>
					<a href="/categories/JavaScript/" title="view all
posts">
						JavaScript (30)
					</a>
				</li>
				
				<li>
					<a href="/categories/AngularJS/" title="view all
posts">
						AngularJS (10)
					</a>
				</li>
				
				<li>
					<a href="/categories/PHP/" title="view all
posts">
						PHP (3)
					</a>
				</li>
				
				<li>
					<a href="/categories/Nodejs/" title="view all
posts">
						Nodejs (13)
					</a>
				</li>
				
			</ul>
		</aside>
	</div>


	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">标签目录</h3>
			<div class="tagcloud" id="tagcloud">
				
					<a href="/tag/Markdown/" title="view all
posts">
						Markdown
					</a>
				
					<a href="/tag/Canvas/" title="view all
posts">
						Canvas
					</a>
				
					<a href="/tag/Git/" title="view all
posts">
						Git
					</a>
				
					<a href="/tag/JavaScript/" title="view all
posts">
						JavaScript
					</a>
				
					<a href="/tag/RegExp/" title="view all
posts">
						RegExp
					</a>
				
					<a href="/tag/DOM/" title="view all
posts">
						DOM
					</a>
				
					<a href="/tag/BOM/" title="view all
posts">
						BOM
					</a>
				
					<a href="/tag/proto/" title="view all
posts">
						proto
					</a>
				
					<a href="/tag/Ajax/" title="view all
posts">
						Ajax
					</a>
				
					<a href="/tag/AngularJS/" title="view all
posts">
						AngularJS
					</a>
				
					<a href="/tag/PHP_study/" title="view all
posts">
						PHP_study
					</a>
				
					<a href="/tag/PHP/" title="view all
posts">
						PHP
					</a>
				
					<a href="/tag/Nodejs_One/" title="view all
posts">
						Nodejs_One
					</a>
				
			</div>

		</aside>
	</div>

	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">友情链接</h3>
			<ul class="minty_thumblist minty_thumblist_a">

				<li>
					<a href="http://blog.csdn.net/u013861109?viewmode=contents" target="blank">
						csdn博客
					</a>
				</li>
				<li>
					<a href="http://www.imooc.com/" target="blank">
						慕课网
					</a>
				</li>
				<li>
					<a href="http://www.dglives.com/" target="blank">
						数字生活前端
					</a>
				</li>
				<li>
					<a href="http://www.jianshu.com/" target="blank">
						简书
					</a>
				</li>
				<li>
					<a href="http://www.runoob.com/" target="blank">
						菜鸟
					</a>
				</li>
				<li>
					<a href="http://www.qdfuns.com/" target="blank">
						前端网
					</a>
				</li>
			</ul>
		</aside>
	</div>

	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">QQ交流群</h3>
			<img style="margin-top: 10px; box-shadow: none;" src="/assets/images/ertw.png">
		</aside>
	</div>


	<script>
	var box=document.getElementById("tagcloud").getElementsByTagName("a");
	for(var i=0;i<box.length;i++){
		var a =Math.round(Math.random()*20)/10;
		box[i].style.fontSize=a+'em';
	}
	</script>

</div>
</div>
	
<footer id="footer">
	<nav class="links">
		<a href="">作品</a>
		<a href="/about/">关于本站</a>
		<a href="/report/">留言板</a>
	</nav>
	<div class="copyright">
		© 2016 <a href="">继小鹏的前端博客</a>
	</div>
	<a href="javascript:pageScroll();" id="rocket" class=""></a>
	<span id="busuanzi_container_site_pv">
	    本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
	<span id="busuanzi_container_site_uv">
	  本站访客数<span id="busuanzi_value_site_uv"></span>人次
	</span>
</footer>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>

$(function(){
	$("#m-btns").click(function(){
		if($("body").hasClass('nav-is-open')){
			$("body").removeClass('nav-is-open')
		}else{
			$("body").addClass('nav-is-open')
		};
	})
})
var fhdb = document.getElementById("rocket");

//获取页面可视区高度
var dqy = document.documentElement.clientHeight;

var main_left=$('#main').offset().left+$('#main').width()+16;

//滚动条滚动时触发   在滚动的时候触发
window.onscroll = function() {
	var sTop = document.documentElement.scrollTop || document.body.scrollTop;
	if (sTop >= dqy) {
		$("#rocket").addClass('show');
	} else {
		$("#rocket").removeClass('show');
	}
}

function pageScroll() {
	//把内容滚动指定的像素数（第一个参数是向右滚动的像素数，第二个参数是向下滚动的像素数）
	window.scrollBy(0, -100);
	//延时递归调用，模拟滚动向上效果
	scrolldelay = setTimeout('pageScroll()', 5);
	//获取scrollTop值，声明了DTD的标准网页取document.documentElement.scrollTop，否则取document.body.scrollTop；因为二者只有一个会生效，另一个就恒为0，所以取和值可以得到网页的真正的scrollTop值
	var sTop = document.documentElement.scrollTop + document.body.scrollTop;
	//判断当页面到达顶部，取消延时代码（否则页面滚动到顶部会无法再向下正常浏览页面）
	if (sTop == 0) clearTimeout(scrolldelay)

}



</script>
</body>
</html>