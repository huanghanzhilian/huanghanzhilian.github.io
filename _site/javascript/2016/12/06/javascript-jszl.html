<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>JavaScript 精粹整理</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="stylesheet" type="text/css" href="/assets/css/main.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/public.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/style.css">
	<link rel="stylesheet" type="text/css" href="/assets/css/pygments.css">
	<link rel="shortcut icon" href="/assets/images/logo_ioc.ico" type="images/x-icon"/>
	<link rel="icon" href="/assets/images/logo_ioc.png" type="images/png"/>
	<script src="http://libs.baidu.com/jquery/1.9.0/jquery.js" type="text/javascript"></script>
	
	<script type="text/javascript">
	    (function($) {

	    	var temp = 0;
	    	$(document).scroll(function() {

	    		if ($(document).scrollTop() > temp) {
	    			$("#header").addClass("hide-top");
	    		} else {
	    			$("#header").removeClass("hide-top");
	    		}
	    		temp = $(document).scrollTop();
	    	});
	    })(jQuery);

	</script>

</head>
<body>
    <header id="header" role="banner">
	<a id="hgroup" href="/" rel="home">
		<h1 id="logo"></h1>
		<i class="slogan" title="返回首页">
			热爱编程，关注前端开发技术
		</i>
	</a>
	<div class="connect">
		<a href="" class="rss"></a>
	</div>
	<nav id="nav">
		<ul class="menu">
			<li class="menu_item">
				<a href="/">首页</a>
			</li>
			<li class="menu_item">
				<a href="/about/">关于本站</a>
			</li>
			<li class="menu_item">
				<a href="/report/">留言板</a>
			</li>
		</ul>
	</nav>
	<div id="m-btns">
		<div class="menu"></div>
	</div>
</header>
	<div id="container" class="clearfix">
	<main id="main" class="hfeed">
		<article id="post-157" class="post-157 hentry">
			<header class="entry-header">
				<h1 class="entry-title">JavaScript 精粹整理</h1>
				<div class="entry-meta">2016-12-06 <span class="dot">•</span>JavaScript<span class="dot">•</span>黄继鹏<span id="busuanzi_container_page_pv">  |  阅读量 <span id="busuanzi_value_page_pv"></span> 次</span></div>
			</header>
			<article class="post-content">
              <p>avaScript 是 弱类型 语言，但并不是没有类型</p>

<h4 id="section">数据类型</h4>

<p>JavaScript 是 <strong>弱类型</strong> 语言，但并不是没有类型，JavaScript可以识别下面 7 种不同类型的值：</p>

<p><strong>基本数据类型</strong></p>

<ol>
  <li>Boolean</li>
  <li>Number</li>
  <li>String</li>
  <li>null</li>
  <li>undefined</li>
  <li>Symbol</li>
</ol>

<p><strong>对象类型Object</strong></p>

<ol>
  <li>Array</li>
  <li>RegExp</li>
  <li>Date</li>
  <li>Math</li>
  <li>…</li>
</ol>

<p>可以使用<code> typeof </code>判断数据类型，操作符返回一个字符串，但并非返回的所有结果都符合预期</p>

<pre><code>typeof false // "boolean"
typeof .2 // "number"
typeof NaN // "number"
typeof '' // "string"
typeof undefined // "undefined"
typeof Symbol() // "symbol"

typeof new Date() // "object"
typeof [] // "object"

typeof alert // "function"

typeof null // "object"
typeof not_defined_var // "undefined"
</code></pre>

<h4 id="section-1">变量</h4>

<p>在应用程序中，使用变量来来为值命名。变量的名称称为<code> identifiers</code></p>

<p><strong>声明</strong></p>

<ol>
  <li>使用关键字 <code>var</code> ：函数作用域</li>
  <li>使用关键字 <code>let</code> ：块作用域 (block scope local variable)</li>
  <li>直接使用：全局作用域</li>
</ol>

<p>.</p>

<pre><code>var global_var = 1;

function fn() {
	var fn_var = 2;

	if (fn_var &gt; 10) {
		let block_var = 3;
		global_var2 = 4;
	}
}
</code></pre>

<p>只声明不赋值，变量的默认值是 <code>undefined</code></p>

<p><code>const</code> 关键字可以声明不可变变量，同样为块作用域。对不可变的理解在对象上的理解需要注意</p>

<pre><code>const num = 1;
const obj = {
	prop: 'value'
};

num = 2; // Uncaught TypeError: Assignment to constant variable.
obj['prop'] = 'value2';

obj = []; // Uncaught TypeError: Assignment to constant variable.
</code></pre>

<p><strong>变量提升</strong></p>

<p>JavaScript中可以引用稍后声明的变量，而不会引发异，这一概念称为变量声明提升(<strong>hoisting</strong>)</p>

<pre><code>console.log(a); // undefined
var a = 2;
</code></pre>

<p>等同于</p>

<pre><code>var a;
console.log(a);
a = 2;
</code></pre>

<h4 id="section-2">函数</h4>

<p>一个函数就是一个可以被外部代码调用(或者函数本身递归调用)的 <code>子程序</code>
定义函数</p>

<ol>
  <li>函数声明</li>
  <li>函数表达式</li>
  <li>Function 构造函数</li>
  <li>箭头函数</li>
</ol>

<p>.</p>

<pre><code>function fn(){}

var fn = function(){}

var fn = new Function(arg1, arg2, ... argN, funcBody)

var fn = (param) =&gt; {}
</code></pre>

<p><strong>arguments</strong></p>

<ol>
  <li>
    <p>arguments:  一个包含了传递给当前执行函数参数的类似于数组的对象</p>
  </li>
  <li>
    <p>arguments.length: 传给函数的参数的数目</p>
  </li>
  <li>
    <p>~~arguments.caller: 调用当前执行函数的函数~~</p>
  </li>
  <li>
    <p>~~arguments.callee: 当前正在执行的函数~~</p>
  </li>
</ol>

<p>.</p>

<pre><code>function foo() {
	return arguments;
}
foo(1, 2, 3); // Arguments[3]
// { "0": 1, "1": 2, "2": 3 }
</code></pre>

<p><strong>rest</strong></p>

<pre><code>function foo(...args) {
	return args;
}
foo(1, 2, 3); // Array[3]
// [1, 2, 3]

function fn(a, b, ...args) {
	return args;
}

fn(1, 2, 3, 4, 5); // Array[3]
// [3, 4, 5]
</code></pre>

<p><strong>default</strong></p>

<p>函数的参数可以在定义的时候约定默认值</p>

<pre><code>function fn(a = 2, b = 3) {
	return a + b;
}


fn(2, 3); // 5

fn(2); // 5

fn(); // 5
</code></pre>

<h4 id="section-3">对象</h4>

<p>JavaScript 中对象是可变<code>键控集合</code>(<strong>keyed collections</strong>)</p>

<p><strong>定义对象</strong></p>

<ol>
  <li>字面量</li>
  <li>构造函数</li>
</ol>

<p>.</p>

<pre><code>var obj = {
	prop: 'value',
	fn: function() {}
};

var date = new Date();
</code></pre>

<p><strong>构造函数</strong></p>

<p>构造函数和普通函数并没有区别，使用<code>new</code>关键字调用就是构造函数，使用构造函数可以 <strong>实例化</strong> 一个对象</p>

<p>函数的返回值有两种可能</p>

<ol>
  <li>
    <p>显式调用<code>return</code>返回<code>return</code>后表达式的求值</p>
  </li>
  <li>
    <p>没有调用<code>return</code>返回<code>undefined</code></p>
  </li>
</ol>

<p>.</p>

<pre><code>function People(name, age) {
	this.name = name;
	this.age = age;
}

var people = new People('Byron', 26);
console.log(people)
</code></pre>

<p><img src="http://upload-images.jianshu.io/upload_images/3877962-55949d1a871cc863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png" /></p>

<p>构造函数返回值</p>

<ol>
  <li>没有返回值</li>
  <li>简单数据类型</li>
  <li>对象类型</li>
</ol>

<p>前两种情况构造函数返回构造对象的实例，<strong>实例化</strong>对象正是利用的这个特性</p>

<p>第三种构造函数和普通函数表现一致，返回<code>return</code>后表达式的结果</p>

<p><strong>prototype</strong></p>

<ol>
  <li>每个函数都有一个 prototype 的对象属性，对象内有一个 constructor 属性，默认指向函数本身</li>
  <li>每个对象都有一个 <strong>proto</strong> 的属性，属相指向其父类型的 prototype</li>
</ol>

<p>.</p>

<pre><code>function Person(name) {
	this.name = name;
}

Person.prototype.print = function() {
	console.log(this.name);
};

var p1 = new Person('Byron');
var p2 = new Person('Casper');

p1.print();
p2.print();
console.log(p1)
</code></pre>

<p><img src="http://upload-images.jianshu.io/upload_images/3877962-f37571c1c251b9e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png" /></p>

<h4 id="this-">this 和作用域</h4>

<p>作用域可以通俗的理解</p>

<ol>
  <li>我是谁</li>
  <li>我有哪些马仔</li>
</ol>

<p>其中我是谁的回答就是 this</p>

<p>马仔就是我的局部变量</p>

<p><strong>this 场景</strong></p>

<p><strong>普通函数</strong></p>

<ol>
  <li>严格模式：<code>undefined</code></li>
  <li>非严格模式: 全局对象</li>
  <li>Node: <code>global</code></li>
  <li>浏览器: <code>window</code></li>
</ol>

<p><strong>构造函数</strong>：对象的实例</p>

<p><strong>对象方法</strong>：对象本身</p>

<p><strong>call &amp; apply</strong></p>

<ol>
  <li>fn.call(context, arg1, arg2, …, argn)</li>
  <li>fn.apply(context, args)</li>
</ol>

<p>.</p>

<pre><code>function isNumber(obj) {
	return Object.prototype.toString.call(obj) === '[object Number]';
}
</code></pre>

<p><strong>Function.prototype.bind</strong></p>

<p><code>bind</code> 返回一个新函数，函数的作用域为 <code>bind</code> 参数</p>

<pre><code>function fn() {
	this.i = 0;

	setInterval(function() {
		console.log(this.i++);
	}.bind(this), 500)
}

fn();
</code></pre>

<p><strong>() =&gt; {}</strong></p>

<p>箭头函数是 <strong>ES6</strong> 提供的新特性，是简写的 <strong>函数表达式</strong>，拥有词法作用域和<code>this</code>值</p>

<pre><code>function fn() {
	this.i = 0;

	setInterval(() =&gt; {
		console.log(this.i++);
	}, 500)
}

fn();
</code></pre>

<h4 id="section-4">继承</h4>

<p>在 JavaScript 的场景，继承有两个目标，子类需要得到父类的：</p>

<ol>
  <li>对象的属性</li>
  <li>对象的方法</li>
</ol>

<p>.</p>

<pre><code>function inherits(child, parent) {
	var _proptotype = Object.create(parent.prototype);
	_proptotype.constructor = child.prototype.constructor;
	child.prototype = _proptotype;
}

function People(name, age) {
	this.name = name;
	this.age = age;
}

People.prototype.getName = function() {
	return this.name;
}

function English(name, age, language) {
	People.call(this, name, age);
	this.language = language;
}

inherits(English, People);

English.prototype.introduce = function() {
	console.log('Hi, I am ' + this.getName());
	console.log('I speak ' + this.language);
}

function Chinese(name, age, language) {
	People.call(this, name, age);
	this.language = language;
}

inherits(Chinese, People);

Chinese.prototype.introduce = function() {
	console.log('你好，我是' + this.getName());
	console.log('我说' + this.language);
}

var en = new English('Byron', 26, 'English');
var cn = new Chinese('色拉油', 27, '汉语');

en.introduce();
cn.introduce();
</code></pre>

<p><strong>ES6 class 与继承</strong></p>

<pre><code>"use strict";

class People {
	constructor(name, age) {
		this.name = name;
		this.age = age;
	}

	getName() {
		return this.name;
	}
}

class English extends People {
	constructor(name, age, language) {
		super(name, age);
		this.language = language;
	}

	introduce() {
		console.log('Hi, I am ' + this.getName());
		console.log('I speak ' + this.language);
	}
}

let en = new English('Byron', 26, 'English');

en.introduce();
</code></pre>

<h4 id="section-5">语法</h4>

<p><strong>label statement</strong></p>

<pre><code>loop:
	for (var i = 0; i &lt; 10; i++) {
		for (var j = 0; j &lt; 5; j++) {
			console.log(j);
			if (j === 1) {
				break loop;
			}
		}
	}

console.log(i);
</code></pre>

<p><strong>语句与表达式</strong></p>

<pre><code>var x = {
	a: 1
};

{
	a: 1
}

{
	a: 1,
	b: 2
}
</code></pre>

<p><strong>立即执行函数</strong></p>

<pre><code>( function() {}() );
( function() {} )();
[ function() {}() ];

~ function() {}();
! function() {}();
+ function() {}();
- function() {}();

delete function() {}();
typeof function() {}();
void function() {}();
new function() {}();
new function() {};

var f = function() {}();

1, function() {}();
1 ^ function() {}();
1 &gt; function() {}();
</code></pre>

<h4 id="section-6">高阶函数</h4>

<p>高阶函数是把函数当做参数或者返回值是函数的函数</p>

<p><strong>回调函数</strong></p>

<pre><code>[1, 2, 3, 4].forEach(function(item) {
	console.log(item);
});
</code></pre>

<p><strong>闭包</strong></p>

<p>闭包由两部分组成</p>

<ol>
  <li>函数</li>
  <li>环境：函数创建时作用域内的局部变量</li>
</ol>

<p>.</p>

<pre><code>function makeCounter(init) {
	var init = init || 0;

	return function() {
		return ++init;
	}
}

var counter = makeCounter(10);

console.log(counter());
console.log(counter());
</code></pre>

<p><strong>典型错误</strong></p>

<pre><code>for (var i = 0; i &lt; doms.length; i++) {
	doms.eq(i).on('click', function(ev) {
		console.log(i);
	});
}

             

for (var i = 0; i &lt; doms.length; i++) {
	(function(i) {
		doms.eq(i).on('click', function(ev) {
			console.log(i);
		});
	})(i);
}
</code></pre>

<p><strong>惰性函数</strong></p>

<pre><code>function eventBinderGenerator() {
	if (window.addEventListener) {
		return function(element, type, handler) {
			element.addEventListener(type, hanlder, false);
		}
	} else {
		return function(element, type, handler) {
			element.attachEvent('on' + type, handler.bind(element, window.event));
		}
	}
}

var addEvent = eventBinderGenerator();
</code></pre>

<p><strong>柯里化</strong></p>

<p>一种允许使用部分参数生成函数的方式</p>

<pre><code>function isType(type) {
	return function(obj) {
		return Object.prototype.toString.call(obj) === '[object ' + type + ']';
	}
}

var isNumber = isType('Number');

console.log(isNumber(1));
console.log(isNumber('s'));

var isArray = isType('Array');

console.log(isArray(1));
console.log(isArray([1, 2, 3]));

       

function f(n) {
	return n * n;
}

function g(n) {
	return n * 2;
}

console.log(f(g(5)));

function pipe(f, g) {
	return function() {
		return f.call(null, g.apply(null, arguments));
	}
}

var fn = pipe(f, g);

console.log(fn(5));
</code></pre>

<p><strong>尾递归</strong></p>

<ol>
  <li>尾调用是指某个函数的最后一步是调用另一个函数</li>
  <li>函数调用自身，称为递归</li>
  <li>如果尾调用自身，就称为尾递归</li>
</ol>

<p>递归很容易发生”栈溢出”错误（stack overflow）</p>

<pre><code>function factorial(n) {
	if (n === 1) return 1;
	return n * factorial(n - 1);
}

factorial(5) // 120
</code></pre>

<p>但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生”栈溢出”错误</p>

<pre><code>function factorial(n, total) {
	if (n === 1) return total;
	return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
</code></pre>

<p>柯里化减少参数</p>

<pre><code>function currying(fn, n) {
	return function(m) {
		return fn.call(this, m, n);
	};
}

function tailFactorial(n, total) {
	if (n === 1) return total;
	return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
</code></pre>

<p><strong>反柯里化</strong></p>

<pre><code>Function.prototype.uncurry = function() {
	return this.call.bind(this);
};
</code></pre>

<p>push 通用化</p>

<pre><code>var push = Array.prototype.push.uncurry();

var arr = [];

push(arr, 1);
push(arr, 2);
push(arr, 3);

console.log(arr);
</code></pre>

              <!-- 多说评论框 start -->
              		<!-- <span class="ds-thread-count" data-thread-key="/javascript/2016/12/06/javascript_jszl" data-count-type="comments"></span> -->
					<div class="ds-thread" data-thread-key="http://yourdomain.com/javascript/2016/12/06/javascript_jszl" data-title="JavaScript 精粹整理" data-url="http://yourdomain.com/javascript/2016/12/06/javascript_jszl"></div>
				<!-- 多说评论框 end -->
				<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
				<script type="text/javascript">
				var duoshuoQuery = {short_name:"huanghuanlian"};
					(function() {
						var ds = document.createElement('script');
						ds.type = 'text/javascript';ds.async = true;
						ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
						ds.charset = 'UTF-8';
						(document.getElementsByTagName('head')[0]
						 || document.getElementsByTagName('body')[0]).appendChild(ds);
					})();
				</script>
				<!-- 多说公共JS代码 end -->


				
            </article>
		</article>

	</main>
	<div class="sidebar" id="sidebar">
	<div class="sidebar-top">
		<aside class="widjhuh">
			<h3 class="widget-title">最新文章</h3>
			<ul class="minty_thumblist">
				
                  <li>
                    <a href="/javascript/2016/12/08/javasctipt-shijian.html">

                    	<span>DOM事件探秘</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/javascript/2016/12/07/javascript-zenzbd.html">

                    	<span>JavaScript 正则表达式</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/javascript/2016/12/06/javascript-mokuai.html">

                    	<span>前端模块化</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/javascript/2016/12/05/javascript-call.html">

                    	<span>JS中的call()和apply()方法</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/javascript/2016/12/05/javascript-bbssm.html">

                    	<span>JavaScript 闭包到底是什么</span>
                    </a>
                  </li>
				
                  <li>
                    <a href="/javascript/2016/12/05/javascript-mxdx.html">

                    	<span>JavaScript面向对象</span>
                    </a>
                  </li>
				
			</ul>
		</aside>
	</div>

	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">最近访客</h3>
			<ul class="minty_thumblist minty_thumblist_a ds-recent-visitors visitorsopi" data-num-items="20" data-avatar-size="38">

			</ul>

		    <!--多说js加载开始，一个页面只需要加载一次 -->
		    <script type="text/javascript">
		    var duoshuoQuery = {short_name:"huanghuanlian"};
		    (function() {
		        var ds = document.createElement('script');
		        ds.type = 'text/javascript';ds.async = true;
		        ds.src = 'http://static.duoshuo.com/embed.js';
		        ds.charset = 'UTF-8';
		        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
		    })();
		    </script>
		    <!--多说js加载结束，一个页面只需要加载一次 -->

		</aside>
	</div>

	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">分类目录</h3>
			<ul class="minty_thumblist minty_thumblist_a">
				
				<li>
					<a href="/categories/Markdown/" title="view all
posts">
						Markdown (2)
					</a>
				</li>
				
				<li>
					<a href="/categories/Canvas/" title="view all
posts">
						Canvas (1)
					</a>
				</li>
				
				<li>
					<a href="/categories/Git/" title="view all
posts">
						Git (1)
					</a>
				</li>
				
				<li>
					<a href="/categories/JavaScript/" title="view all
posts">
						JavaScript (13)
					</a>
				</li>
				
			</ul>
		</aside>
	</div>


	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">标签目录</h3>
			<div class="tagcloud" id="tagcloud">
				
					<a href="/tag/Markdown/" title="view all
posts">
						Markdown
					</a>
				
					<a href="/tag/Canvas/" title="view all
posts">
						Canvas
					</a>
				
					<a href="/tag/Git/" title="view all
posts">
						Git
					</a>
				
					<a href="/tag/JavaScript/" title="view all
posts">
						JavaScript
					</a>
				
					<a href="/tag/DOM/" title="view all
posts">
						DOM
					</a>
				
			</div>

		</aside>
	</div>

	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">友情链接</h3>
			<ul class="minty_thumblist minty_thumblist_a">

				<li>
					<a href="http://blog.csdn.net/u013861109?viewmode=contents" target="blank">
						csdn博客
					</a>
				</li>
				<li>
					<a href="http://www.imooc.com/" target="blank">
						慕课网
					</a>
				</li>
				<li>
					<a href="http://www.dglives.com/" target="blank">
						数字生活前端
					</a>
				</li>
				<li>
					<a href="http://www.jianshu.com/" target="blank">
						简书
					</a>
				</li>
				<li>
					<a href="http://www.runoob.com/" target="blank">
						菜鸟
					</a>
				</li>
				<li>
					<a href="http://www.qdfuns.com/" target="blank">
						前端网
					</a>
				</li>
			</ul>
		</aside>
	</div>

	<div class="sidebar-top">
		<aside class="widjhuh clearfix">
			<h3 class="widget-title">QQ交流群</h3>
			<img style="margin-top: 10px; box-shadow: none;" src="/assets/images/ertw.png">
		</aside>
	</div>


	<script>
	var box=document.getElementById("tagcloud").getElementsByTagName("a");
	for(var i=0;i<box.length;i++){
		var a =Math.round(Math.random()*20)/10;
		box[i].style.fontSize=a+'em';
	}
	</script>

</div>
</div>
	<footer id="footer">
	<nav class="links">
		<a href="">作品</a>
		<a href="/about/">关于本站</a>
		<a href="/report/">留言板</a>
	</nav>
	<div class="copyright">
		© 2016 <a href="">继小鹏的前端博客</a>
	</div>
	<a href="javascript:pageScroll();" id="rocket" class=""></a>
	<span id="busuanzi_container_site_pv">
	    本站总访问量<span id="busuanzi_value_site_pv"></span>次
	</span>
	<span id="busuanzi_container_site_uv">
	  本站访客数<span id="busuanzi_value_site_uv"></span>人次
	</span>
</footer>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script>
var fhdb = document.getElementById("rocket");

//获取页面可视区高度
var dqy = document.documentElement.clientHeight;

var main_left=$('#main').offset().left+$('#main').width()+16;

//滚动条滚动时触发   在滚动的时候触发
window.onscroll = function() {
	var sTop = document.documentElement.scrollTop || document.body.scrollTop;
	if (sTop >= dqy) {
		$("#rocket").addClass('show');
	} else {
		$("#rocket").removeClass('show');
	}
}

function pageScroll() {
	//把内容滚动指定的像素数（第一个参数是向右滚动的像素数，第二个参数是向下滚动的像素数）
	window.scrollBy(0, -100);
	//延时递归调用，模拟滚动向上效果
	scrolldelay = setTimeout('pageScroll()', 30);
	//获取scrollTop值，声明了DTD的标准网页取document.documentElement.scrollTop，否则取document.body.scrollTop；因为二者只有一个会生效，另一个就恒为0，所以取和值可以得到网页的真正的scrollTop值
	var sTop = document.documentElement.scrollTop + document.body.scrollTop;
	//判断当页面到达顶部，取消延时代码（否则页面滚动到顶部会无法再向下正常浏览页面）
	if (sTop == 0) clearTimeout(scrolldelay)

}



</script>
</body>
</html>