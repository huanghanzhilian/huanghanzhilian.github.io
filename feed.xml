<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>继小鹏的博客</title>
    <description>Actually, less is more!</description>
    <link>http://www.huanghanlian.com/</link>
    <atom:link href="http://www.huanghanlian.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 11 Mar 2017 23:51:37 +0800</pubDate>
    <lastBuildDate>Sat, 11 Mar 2017 23:51:37 +0800</lastBuildDate>
    <generator>Jekyll v3.0.0</generator>
    
      <item>
        <title>AngularJS快速入手1-1</title>
        <description>
</description>
        <pubDate>Sat, 11 Mar 2017 23:46:13 +0800</pubDate>
        <link>http://www.huanghanlian.com/angularjs/2017/03/11/angularjs-basics2.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/angularjs/2017/03/11/angularjs-basics2.html</guid>
        
        <category>AngularJS</category>
        
        
        <category>AngularJS</category>
        
      </item>
    
      <item>
        <title>AngularJS快速入手1-1</title>
        <description>&lt;h3 id=&quot;angularjs&quot;&gt;AngularJS简介&lt;/h3&gt;

&lt;p&gt;目前最新版本1.3.0&lt;/p&gt;

&lt;p&gt;放弃了ie8&lt;/p&gt;

&lt;p&gt;引入了单向数据绑定&lt;/p&gt;

&lt;p&gt;删掉了一些过时的api (据说是为了AngularJS2.0做准备)&lt;/p&gt;

&lt;h3 id=&quot;angularjs-4&quot;&gt;AngularJS-实例演示4大核心特性&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1 .MVC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-7706890b00d0fa54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;```html
&amp;lt;!doctype html&amp;gt;&lt;/p&gt;
&lt;html ng-app=&quot;&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;!-- ng-controller我们的控制器  ng-controller赋值成HelloAngular --&gt;
        &lt;div ng-controller=&quot;HelloAngular&quot;&gt;
            &lt;!-- p标签充当了视图的功能 --&gt;
            &lt;!-- 取值这个地方就是充当数据模型 --&gt;
            &lt;p&gt;,Angular&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;!-- 导入了angular-1.3.0.js文件 --&gt;
    &lt;script src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        //HelloAngular这个函数充当了控制器
        function HelloAngular($scope) {
            $scope.greeting = {
                text: &#39;Hello&#39;
            };
        }
    &lt;/script&gt;
&lt;/html&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;运行效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-65e2b7e3decbbd7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 模块化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;html&lt;/p&gt;

&lt;p&gt;```html
&amp;lt;!doctype html&amp;gt;&lt;/p&gt;
&lt;html ng-app=&quot;HelloAngular&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div ng-controller=&quot;helloAngular&quot;&gt;
            &lt;p&gt;,Angular&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;HelloAngular_Module.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;javascript&lt;/p&gt;

&lt;p&gt;``` javascript
//这里调用了angular.module方法
var myModule = angular.module(“HelloAngular”, []);&lt;/p&gt;

&lt;p&gt;myModule.controller(“helloAngular”, [‘$scope’,
    function HelloAngular($scope) {
        $scope.greeting = {
            text: ‘Hello’
        };
    }
]);
```&lt;/p&gt;

&lt;p&gt;运行效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-275f189bedad7699.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在HelloAngular_Module.js文件中调用了angular.module方法，然后给他一个字符串“HelloAngular”，后面还传了方括号空数组，通过字面量看出这是在定义一个模块，var myModule是一个模块，定义完模块后在模块上面调用了一个controller方法很显然这是告诉angular要生成一个控制器”helloAngular”是控制器的名称，后面方括号里面第一个参数’$scope’是告诉angularjs帮我注入’$scope’。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-011b390978faa7f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AngularJS概念有Module，有Directive，有Filter，其实一点要抓住一个点，一切都是从模块开始的，在AngularJS开发中首先想到的是模块也就是&lt;strong&gt;Module&lt;/strong&gt;，其他所有的东西其实都是挂在&lt;strong&gt;Module&lt;/strong&gt;下面的，因为只有把模块创建后你才能在模块上去调用Service,controller等方法，所以首先想到的是模块，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 指令系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;html&lt;/p&gt;

&lt;p&gt;```html
&amp;lt;!doctype html&amp;gt;&lt;/p&gt;
&lt;html ng-app=&quot;MyModule&quot;&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot; /&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;hello&gt;&lt;/hello&gt;
	&lt;/body&gt;
	&lt;script src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt;
	&lt;script src=&quot;HelloAngular_Directive.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;javascript&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var myModule = angular.module(&quot;MyModule&quot;, []);
myModule.directive(&quot;hello&quot;, function() {
    return {
        restrict: &#39;E&#39;,
        template: &#39;&amp;lt;div&amp;gt;Hi everyone!&amp;lt;/div&amp;gt;&#39;,
        replace: true
    }
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;运行效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-d688b09b01e01ac8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看看body表情内的&lt;hello&gt;&lt;/hello&gt;标签，很显然浏览器是不认识这个标签的，不认识他在默认情况下浏览器会忽略他，Angular js就会想一下怎样能让浏览器认识这个标签呢，这就需要借助Angular js的Directive这个特性，&lt;/p&gt;

&lt;p&gt;一切都是从模块开始的，所以我们需要创建模块&lt;/p&gt;

&lt;p&gt;``` javascript
var myModule = angular.module(“MyModule”, []);&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
var myModule = angular.module(&quot;MyModule&quot;, []);
myModule.directive(&quot;hello&quot;, function() {
    return {
        restrict: &#39;E&#39;,
        template: &#39;&amp;lt;div&amp;gt;Hi everyone!&amp;lt;/div&amp;gt;&#39;,
        replace: true
    }
});
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;模块创建好再调用模块上面directive方法，这个方法也有两个参数&lt;code&gt;&quot;hello&quot;&lt;/code&gt;是指令的名称，也就是对应的标签名，后面是一个函数，这个函数就是生成标签的， template: ‘&amp;lt;div&amp;gt;Hi everyone!&amp;lt;/div&amp;gt;’,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-15bff53254dc9fec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最终hello是被替换成模板template，&lt;/p&gt;

&lt;p&gt;这个就是angular的指令
我们可以自定义一大堆的指令然后做一些封装我们在调用的时候会非常方便，当然指令不只是定义标签这么简单，还有很多其他功能，比如说&lt;/p&gt;

&lt;p&gt;```html
&amp;lt;!doctype html&amp;gt;&lt;/p&gt;
&lt;html ng-app=&quot;MyModule&quot;&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot; /&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;hello&gt;&lt;/hello&gt;
	&lt;/body&gt;
	&lt;script src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt;
	&lt;script src=&quot;HelloAngular_Directive.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;我们在html里面ng-app=”MyModule”,这个实际上就是一个指令，这里复制ng-app等于”MyModule”&lt;/p&gt;

&lt;p&gt;“MyModule”在var myModule = angular.module(“MyModule”, []);js里，很显然是告诉Angular js要去使用我们这个模块，ng-app意思和C语言里的main或者是java里面的main方法。&lt;/p&gt;

&lt;p&gt;Angular js检测到ng-app这个指令的时候就知道我从ng-app这个指令开始内部的标签内容就归我Angular js来管了，也就是说Angular js从ng-app这个地方启动的，可以想象既然是main函数main方法，一个应用里面显然只能有一个，所以在任意一个单页Angular js应用里面ng-app这个指令只能出现一次。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-2969be9fb6c72e5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 双向数据绑定&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Angular js 是实现了双向数据绑定，其他的前端框架都没有实现这样一个特性，目前大多数前端框架都是实现单向数据绑定。&lt;/p&gt;

&lt;p&gt;来看看单向数据绑定的流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-4f67727e7c975367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先是我们把模板写好，再加上数据，数据可能是从后台服务端读进来的，模板和数据结合在一起，通过数据绑定机制生成一段html标签然后把这段标签插入到文档流里面，这是经典单向数据绑定的处理流程。&lt;/p&gt;

&lt;p&gt;html一旦生成完以后就没法再变了，当有新的数据的时候我们只能重新再来一遍。&lt;/p&gt;

&lt;p&gt;Angular js认为单向数据绑定的过程实在是不怎么优雅，所以他觉得我应该实现双向数据绑定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-ee3f8ae4464562b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;他的核心想法是这样的，&lt;/p&gt;

&lt;p&gt;视图，数据是对应的当视图上的内容发生变化的时候他希望数据模型里面立刻发生变化，当数据模型发生变化的时候视图自己自动会去更新，很显然这里需要  借助一个事件机制。&lt;/p&gt;

&lt;p&gt;在html里有什么样的视图会发生变化？表单。在很多的页面中会出现很多的表单，表单是来收集用户的输入的，这些数据是非常容易变化的，在数据发生变化就会通过Angular js机制同步到数据模型上面。&lt;/p&gt;

&lt;p&gt;html&lt;/p&gt;

&lt;p&gt;```html
&amp;lt;!doctype html&amp;gt;&lt;/p&gt;
&lt;html ng-app=&quot;&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;input ng-model=&quot;greeting.text&quot; /&gt;
            &lt;p&gt;,AngularJS&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script src=&quot;js/angular-1.3.0.js&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;运行效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-8df2bddb9e767ce3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面代码实现效果在input输入框输入任何东西底下的显示框都会立刻显示，&lt;/p&gt;

&lt;p&gt;这是什么原理呢&lt;/p&gt;

&lt;p&gt;```html
&lt;input ng-model=&quot;greeting.text&quot; /&gt;&lt;/p&gt;
&lt;p&gt;,AngularJS&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;首先有一个输入框
然后绑定了一个ng-model=”greeting.text”,
这个是时候底下有个p标签有个双花括号来获取greeting.text的值。
双花括号是什么意思呢？
在Angular js里面是取值的意思，是一个取值表达式。&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Mar 2017 23:45:13 +0800</pubDate>
        <link>http://www.huanghanlian.com/angularjs/2017/03/11/angularjs-basics1.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/angularjs/2017/03/11/angularjs-basics1.html</guid>
        
        <category>AngularJS</category>
        
        
        <category>AngularJS</category>
        
      </item>
    
      <item>
        <title>Ajax全接触(五) 处理跨域方式</title>
        <description>&lt;p&gt;那么什么是跨域呢？&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;处理跨域方式-代理&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-3b7e68f4ceee1be1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们在前端代码中将ajax访问后台&lt;code&gt;url&lt;/code&gt;改成&lt;code&gt;http://127.0.0.1:80/dengtu/serverjsonp.php&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {
	$(&quot;#search&quot;).click(function() {
		$.ajax({
			type: &quot;GET&quot;,
			url: &quot;http://127.0.0.1:80/dengtu/serverjsonp.php?number=&quot; + $(&quot;#keyword&quot;).val(),
			dataType: &quot;json&quot;,
			success: function(data) {
				if (data.success) {
					$(&quot;#searchResult&quot;).html(data.msg);
				} else {
					$(&quot;#searchResult&quot;).html(&quot;出现错误：&quot; + data.msg);
				}
			},
			error: function(jqXHR) {
				alert(&quot;发生错误：&quot; + jqXHR.status);
			},
		});
	});

	$(&quot;#save&quot;).click(function() {
		$.ajax({
			type: &quot;POST&quot;,
			url: &quot;http://127.0.0.1:80/dengtu/serverjsonp.php&quot;,
			data: {
				name: $(&quot;#staffName&quot;).val(),
				number: $(&quot;#staffNumber&quot;).val(),
				sex: $(&quot;#staffSex&quot;).val(),
				job: $(&quot;#staffJob&quot;).val()
			},
			dataType: &quot;json&quot;,
			success: function(data) {
				if (data.success) {
					$(&quot;#createResult&quot;).html(data.msg);
				} else {
					$(&quot;#createResult&quot;).html(&quot;出现错误：&quot; + data.msg);
				}
			},
			error: function(jqXHR) {
				alert(&quot;发生错误：&quot; + jqXHR.status);
			},
		});
	});
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;http://127.0.0.1:80/dengtu&lt;/code&gt;指向的也是&lt;code&gt;http://localhost/dengtu&lt;/code&gt;但是他们不是一个域名，&lt;/p&gt;

&lt;p&gt;这样我们能访问到吗？&lt;/p&gt;

&lt;p&gt;答案是不能，返回错误告诉你没有权限访问。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-ff2eed58c0e4bf74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这就要用到跨域了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么什么是跨域呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JavaScript出于安全方面的考虑，不允许跨域调用其他页面的对象，什么是跨域呢，简单的理解就是因为JavaScript同源策略的限制，a.com域名下的js无法操作b.com或c.a.com域名下的对象。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-090891382cc0ad71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;子域名不相同都会认为是跨域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-46750de75c3040aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过代理跨域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;举个例子在上海服务器上，有一个服务&lt;/p&gt;

&lt;p&gt;&lt;code&gt;www.shanghai.com/service.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在北京服务器上也有个服务&lt;/p&gt;

&lt;p&gt;&lt;code&gt;www.beijing.com/proxy.php&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;北京这个服务其实是从后端去访问上海的这个服务&lt;code&gt;www.shanghai.com/service.php&lt;/code&gt;然后把服务的响应值获取过来，返回给前端，&lt;/p&gt;

&lt;p&gt;也就是北京的服务在后台做了个代理，这样前端只需要访问北京的代理的服务也就相当于访问了上海的服务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-b72374f8f64ddb0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;jsonp&quot;&gt;处理跨域方式–JSONP&lt;/h4&gt;

&lt;p&gt;JSONP不支持post方式&lt;/p&gt;

&lt;p&gt;在jquery的ajax中使用git方式访问跨域，&lt;/p&gt;

&lt;p&gt;前端&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;需要改变&lt;code&gt;dataType: &quot;jsonp&quot;,&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着再增加一个属性&lt;code&gt;jsonp:&quot;callback&quot;,&lt;/code&gt;&lt;code&gt;jsonp:&quot;任意值&quot;,&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;后端&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在git请求处理中，获取到&lt;code&gt;callback&lt;/code&gt;，&lt;code&gt;$jsonp=$_GET[&quot;callback&quot;];&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;改变返回值，&lt;code&gt;echo $jsonp.&#39;({&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;})&#39;;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前端代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(document).ready(function() {
	$(&quot;#search&quot;).click(function() {
		$.ajax({
			type: &quot;GET&quot;,
			url: &quot;http://127.0.0.1:80/dengtu/serverjsonp.php?number=&quot; + $(&quot;#keyword&quot;).val(),
			dataType: &quot;jsonp&quot;,
			jsonp:&quot;callback&quot;,
			success: function(data) {
				if (data.success) {
					$(&quot;#searchResult&quot;).html(data.msg);
				} else {
					$(&quot;#searchResult&quot;).html(&quot;出现错误：&quot; + data.msg);
				}
			},
			error: function(jqXHR) {
				alert(&quot;发生错误：&quot; + jqXHR.status);
			},
		});
	});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后端代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//通过员工编号搜索员工
function search(){
	$jsonp=$_GET[&quot;callback&quot;];
	//检查是否有员工编号的参数
	//isset检测变量是否设置；empty判断值为否为空
	//超全局变量 $_GET 和 $_POST 用于收集表单数据
	if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) {
		echo $jsonp.&#39;({&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;})&#39;;
		return;
	}
	//函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
	//global 关键词用于访问函数内的全局变量
	global $staff;
	//获取number参数
	$number = $_GET[&quot;number&quot;];
	$result = $jsonp.&#39;({&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;})&#39;;
	
	//遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
	foreach ($staff as $value) {
		if ($value[&quot;number&quot;] == $number) {
			$result = $jsonp.&#39;({&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：&#39; . $value[&quot;number&quot;] . 
							&#39;，员工姓名：&#39; . $value[&quot;name&quot;] . 
							&#39;，员工性别：&#39; . $value[&quot;sex&quot;] . 
							&#39;，员工职位：&#39; . $value[&quot;job&quot;] . &#39;&quot;})&#39;;
			break;
		}
	}
    echo $result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就能通过jsonp来获取跨域信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;callback和jsonp的作用和原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1先定义一个”callback123”字段用来映射jquery生成的jQueryxxxxx_xxxxx函数名（这个函数在服务器处理完毕并返回数据时再由jquery调用）；&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;然后jsonp协议直接请求&lt;code&gt;http://127.0.0.1:8080/ajaxdemo/service.php?number=111；&lt;/code&gt;（个人感觉jsonp协议不受同源策略限制）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接着服务器端定义变量$jsonp获取请求中名为”callback123”的值，也就是获取到回调函数名”jQueryxxxxx_xxxxx”；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;再接着服务器处理完毕后将数据放到回调函数中，也就是视频中老师以jQueryxxxxx_xxxxx(jsondata)这种$jsonp拼接(jsondata)的形式返回给前端；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后前端接收到”jQueryxxxxx_xxxxx(jsondata)”，jquery调用这个jQueryxxxxx_xxxxx函数，将jsondata传入到success中的function中，这样就实现了跨域。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;xhr2&quot;&gt;处理跨域方式–XHR2&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-4936aeb13b5f82bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;XMR2方法不支持ie10以下版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用XMR2方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在服务端改写脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;header(&#39;Access-Control-Allow-Origin:*&#39;);   //值设置为*。*意思是所有域都可以访问，当然可以设置特定的域名
header(&#39;Access-Control-Allow-Methods:POST,GET&#39;);  //允许post/git
header(&#39;Access-Control-Allow-Credentials:true&#39;); 
header(&quot;Content-Type: application/json;charset=utf-8&quot;); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就能做到跨域&lt;/p&gt;

</description>
        <pubDate>Tue, 20 Dec 2016 13:00:17 +0800</pubDate>
        <link>http://www.huanghanlian.com/javascript/2016/12/20/js-ajax5.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/javascript/2016/12/20/js-ajax5.html</guid>
        
        <category>Ajax</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>Ajax全接触(四) jQuery中的AJAX</title>
        <description>&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;语法&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;Query.ajax([*settings*])
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;em&gt;settings&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;可选。用于配置 Ajax 请求的键值对集合。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;可以通过 $.ajaxSetup() 设置任何选项的默认值。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;type&lt;/td&gt;
      &lt;td&gt;类型：String&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;url&lt;/td&gt;
      &lt;td&gt;类型：String&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;默认值: 当前页地址。发送请求的地址。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;data&lt;/td&gt;
      &lt;td&gt;是一个对象，连同请求发送到服务器的数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dataType&lt;/td&gt;
      &lt;td&gt;预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，一般我们采用json格式，可以设置为json&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;success&lt;/td&gt;
      &lt;td&gt;是一个方法，请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;error&lt;/td&gt;
      &lt;td&gt;是一个方法，请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE HTML&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
body, input, select, button, h1 {
	font-size: 28px;
	line-height:1.7;
}
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;

	&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

	&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
	&amp;lt;input type=&quot;text&quot; id=&quot;keyword&quot; /&amp;gt;
	&amp;lt;button id=&quot;search&quot;&amp;gt;查询&amp;lt;/button&amp;gt;
	&amp;lt;p id=&quot;searchResult&quot;&amp;gt;&amp;lt;/p&amp;gt;

	&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
	&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
	&amp;lt;input type=&quot;text&quot; id=&quot;staffName&quot; /&amp;gt;&amp;lt;br&amp;gt;
	&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
	&amp;lt;input type=&quot;text&quot; id=&quot;staffNumber&quot; /&amp;gt;&amp;lt;br&amp;gt;
	&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
	&amp;lt;select id=&quot;staffSex&quot;&amp;gt;
	&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
	&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
	&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
	&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
	&amp;lt;input type=&quot;text&quot; id=&quot;staffJob&quot; /&amp;gt;&amp;lt;br&amp;gt;
	&amp;lt;button id=&quot;save&quot;&amp;gt;保存&amp;lt;/button&amp;gt;
	&amp;lt;p id=&quot;createResult&quot;&amp;gt;&amp;lt;/p&amp;gt;

	&amp;lt;script src=&quot;http://apps.bdimg.com/libs/jquery/1.11.1/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
	&amp;lt;script&amp;gt;
		$(document).ready(function() {
			$(&quot;#search&quot;).click(function() {
				$.ajax({
					type: &quot;GET&quot;,
					url: &quot;serverjson2.php?number=&quot; + $(&quot;#keyword&quot;).val(),
					dataType: &quot;json&quot;,
					success: function(data) {
						if (data.success) {
							$(&quot;#searchResult&quot;).html(data.msg);
						} else {
							$(&quot;#searchResult&quot;).html(&quot;出现错误：&quot; + data.msg);
						}
					},
					error: function(jqXHR) {
						alert(&quot;发生错误：&quot; + jqXHR.status);
					},
				});
			});

			$(&quot;#save&quot;).click(function() {
				$.ajax({
					type: &quot;POST&quot;,
					url: &quot;serverjson.php&quot;,
					data: {
						name: $(&quot;#staffName&quot;).val(),
						number: $(&quot;#staffNumber&quot;).val(),
						sex: $(&quot;#staffSex&quot;).val(),
						job: $(&quot;#staffJob&quot;).val()
					},
					dataType: &quot;json&quot;,
					success: function(data) {
						if (data.success) {
							$(&quot;#createResult&quot;).html(data.msg);
						} else {
							$(&quot;#createResult&quot;).html(&quot;出现错误：&quot; + data.msg);
						}
					},
					error: function(jqXHR) {
						alert(&quot;发生错误：&quot; + jqXHR.status);
					},
				});
			});
		});
	&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 12:59:57 +0800</pubDate>
        <link>http://www.huanghanlian.com/javascript/2016/12/20/js-ajax4.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/javascript/2016/12/20/js-ajax4.html</guid>
        
        <category>Ajax</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>Ajax全接触(三)JSON格式</title>
        <description>&lt;p&gt;JSON是存储和交换文本信息的语法，类似与XML。它采用键值的方式来组织，易于人们阅读和编写，同时也易于解析和生成&lt;/p&gt;

&lt;h4 id=&quot;json&quot;&gt;json基本概念&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JSON:JavaScript对象表示法，(JavaScript Object Notation)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JSON是存储和交换文本信息的语法，类似与XML。它采用键值的方式来组织，易于人们阅读和编写，同时也易于解析和生成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JSON是独立于语言的，也就是说不管什么语言，都可以解析JSON，只需要按照JSON的规则来就行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jsonxml&quot;&gt;json与XML比较&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;json的长度和xml格式比起来很短小&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;json读写的速度更快&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;json可以使用javascript内建方法直接进行解析，转成javascript对象，非常方便。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;json-1&quot;&gt;JSON语法规则&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JSON 数据的书写格式是：名称/值对。&lt;/strong&gt;  &lt;br /&gt;
名称/值对组合中的名称写在前面(在双引号中)，值对写在后面(同样在双引号中)，中间用冒号隔开：比如&lt;code&gt;&quot;name&quot;:&quot;郭靖&quot;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;json的值可以是下面这些类型：&lt;/strong&gt;  &lt;br /&gt;
数字(整数或浮点数)，比如123，1.23
字符串(在双引号中)
逻辑值(true或false)
数组(在方括号中)
对象(在花括号中)
null&lt;/p&gt;

    &lt;p&gt;{
      “staff”:[
          {“name”:”洪七”,”age”:”70”},
          {“name”:”郭靖”,”age”:”35”},
          {“name”:”黄蓉”,”age”:”30”},
      ]
  }&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个典型的json。他首先用花括号括起来，表示这是一个json对象，对象里面有一个值对，这个值对名称叫staff，他的值是一个数组，这个数组是由很多晓得json对象组成，对象里面又有两个属性。&lt;/p&gt;

&lt;h4 id=&quot;json-2&quot;&gt;json解析、格式化和校验工具&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;json解析javascript&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在js中解析json有两种方式eval和JSON.parse&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;eval方法&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jsonobj = &#39;{&quot;staff&quot;:[{&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:&quot;70&quot;},{&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:&quot;35&quot;},{&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:&quot;30&quot;},]}&#39;
var jsonop = eval(&#39;(&#39; + jsonobj + &#39;)&#39;);
alert(jsonop.staff[0].name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-483a285fec5215a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;JSON.parse方法&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var jsonobj = &#39;{&quot;staff&quot;:[{&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:&quot;70&quot;},{&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:&quot;35&quot;},{&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:&quot;30&quot;}]}&#39;
var jsonop = JSON.parse(jsonobj);
alert(jsonop.staff[0].name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-ed7a6331fe80e4a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：用eval方法执行他不会去看你的json字符串是否合法，而且json中一些js方法会直接的执行，这是非常的危险。 所以尽量使用JSON.parse方法，来去解析json字符串，能返回一些语法错误，又安全又方便。&lt;/p&gt;

&lt;p&gt;json在书写的时候非常容易出错，所以把json字符串进行校验是必不可少的。&lt;/p&gt;

&lt;p&gt;推荐json校验在线工具&lt;a href=&quot;http://jsonlint.com/&quot;&gt;jsonlint.com&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;ajaxjson&quot;&gt;AJAX使用json方式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
header(&quot;Content-Type: text/plain;charset=utf-8&quot;); 
//header(&quot;Content-Type: application/json;charset=utf-8&quot;); 
//header(&quot;Content-Type: text/xml;charset=utf-8&quot;); 
//header(&quot;Content-Type: text/html;charset=utf-8&quot;); 
//header(&quot;Content-Type: application/javascript;charset=utf-8&quot;); 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器端返回json对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//通过员工编号搜索员工
function search(){
	//检查是否有员工编号的参数
	//isset检测变量是否设置；empty判断值为否为空
	//超全局变量 $_GET 和 $_POST 用于收集表单数据
	if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) {
		echo &#39;{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;}&#39;;
		return;
	}
	//函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
	//global 关键词用于访问函数内的全局变量
	global $staff;
	//获取number参数
	$number = $_GET[&quot;number&quot;];
	$result = &#39;{&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;}&#39;;
	
	//遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
	foreach ($staff as $value) {
		if ($value[&quot;number&quot;] == $number) {
			$result = &#39;{&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：&#39; . $value[&quot;number&quot;] . 
							&#39;，员工姓名：&#39; . $value[&quot;name&quot;] . 
							&#39;，员工性别：&#39; . $value[&quot;sex&quot;] . 
							&#39;，员工职位：&#39; . $value[&quot;job&quot;] . &#39;&quot;}&#39;;
			break;
		}
	}
    echo $result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回json格式信息&lt;/p&gt;

&lt;p&gt;查询错误是返回&lt;code&gt;{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误&quot;}&lt;/code&gt;json格式对象&lt;/p&gt;

&lt;p&gt;没有找到员工时返回&lt;code&gt;{&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;}&lt;/code&gt;json格式对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//创建员工
function create(){
	//判断信息是否填写完全
	if (!isset($_POST[&quot;name&quot;]) || empty($_POST[&quot;name&quot;])
		|| !isset($_POST[&quot;number&quot;]) || empty($_POST[&quot;number&quot;])
		|| !isset($_POST[&quot;sex&quot;]) || empty($_POST[&quot;sex&quot;])
		|| !isset($_POST[&quot;job&quot;]) || empty($_POST[&quot;job&quot;])) {
		echo &#39;{&quot;success&quot;:false,&quot;msg&quot;:&quot;参数错误，员工信息填写不全&quot;}&#39;;
		return;
	}
	//TODO: 获取POST表单数据并保存到数据库
	
	//提示保存成功
	echo &#39;{&quot;success&quot;:true,&quot;msg&quot;:&quot;员工：&#39; . $_POST[&quot;name&quot;] . &#39; 信息保存成功！&quot;}&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新建员工时错误时也返回json对象&lt;/p&gt;

&lt;p&gt;客户端修改&lt;/p&gt;

&lt;p&gt;客户端要把服务端传来的json格式对象进行解析&lt;/p&gt;

&lt;p&gt;查询修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById(&quot;search&quot;).onclick = function() { 
	var request = new XMLHttpRequest();
	request.open(&quot;GET&quot;, &quot;serverjson.php?number=&quot; + document.getElementById(&quot;keyword&quot;).value);
	request.send();
	request.onreadystatechange = function() {
		if (request.readyState===4) {
			if (request.status===200) { 
				var data = JSON.parse(request.responseText);
				if (data.success) { 
					document.getElementById(&quot;searchResult&quot;).innerHTML = data.msg;
				} else {
					document.getElementById(&quot;searchResult&quot;).innerHTML = &quot;出现错误：&quot; + data.msg;
				}
			} else {
				alert(&quot;发生错误：&quot; + request.status);
			}
		} 
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;var data = JSON.parse(request.responseText);&lt;/code&gt;定义变量data使用JSON.parse解析获取的json数据。再进行判断显示在页面&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.getElementById(&quot;save&quot;).onclick = function() { 
	var request = new XMLHttpRequest();
	request.open(&quot;POST&quot;, &quot;serverjson.php&quot;);
	var data = &quot;name=&quot; + document.getElementById(&quot;staffName&quot;).value 
	                  + &quot;&amp;amp;number=&quot; + document.getElementById(&quot;staffNumber&quot;).value 
	                  + &quot;&amp;amp;sex=&quot; + document.getElementById(&quot;staffSex&quot;).value 
	                  + &quot;&amp;amp;job=&quot; + document.getElementById(&quot;staffJob&quot;).value;
	request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
	request.send(data);
	request.onreadystatechange = function() {
		if (request.readyState===4) {
			if (request.status===200) { 
				var data = JSON.parse(request.responseText);
				if (data.success) { 
					document.getElementById(&quot;createResult&quot;).innerHTML = data.msg;
				} else {
					document.getElementById(&quot;createResult&quot;).innerHTML = &quot;出现错误：&quot; + data.msg;
				}
			} else {
				alert(&quot;发生错误：&quot; + request.status);
			}
		} 
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;wei&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 12:59:51 +0800</pubDate>
        <link>http://www.huanghanlian.com/javascript/2016/12/20/js-ajax3.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/javascript/2016/12/20/js-ajax3.html</guid>
        
        <category>Ajax</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>Ajax全接触(二)例子ajax+php</title>
        <description>&lt;p&gt;接触Ajax&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;例子要求&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;查询员工信息，可以通过输入员工编号查询员工基本信息；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;新建员工信息，包含员工姓名，员工编号，员工性别，员工职位；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-1&quot;&gt;实现步骤&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;纯html页面，用来实现员工查询和新建的页面；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;php页面，用来实现员工查询和新建员工的后台接口；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-9d69936adb40e955.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在本地部署web服务器，用户来测试，通过本地web服务器，我们可以及时的查看编写的php代码实际效果。&lt;/p&gt;

&lt;p&gt;选择一个一体软件包，XAMMP&lt;a href=&quot;https://www.apachefriends.org/download.html&quot;&gt;https://www.apachefriends.org/download.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-92d38a00a7841c00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载即可，傻瓜化安装。&lt;/p&gt;

&lt;h4 id=&quot;ajax-&quot;&gt;Ajax-服务器端实现&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;设置页面内容是html编码格式是utf-8。防止页面返回值是乱码。&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
//设置页面内容是html编码格式是utf-8
header(&quot;Content-Type: text/plain;charset=utf-8&quot;);                  //代表格式是纯文本
//header(&quot;Content-Type: application/json;charset=utf-8&quot;);          //代表格式是json字符串
//header(&quot;Content-Type: text/xml;charset=utf-8&quot;);
//header(&quot;Content-Type: text/html;charset=utf-8&quot;);
//header(&quot;Content-Type: application/javascript;charset=utf-8&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;定义一个多维数组，包含员工的信息，每条员工信息为一个数组&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$staff = array
	(
		array(&quot;name&quot; =&amp;gt; &quot;洪七&quot;, &quot;number&quot; =&amp;gt; &quot;101.&quot;, &quot;sex&quot; =&amp;gt; &quot;男&quot;, &quot;job&quot; =&amp;gt; &quot;总经理&quot;),
		array(&quot;name&quot; =&amp;gt; &quot;郭靖&quot;, &quot;number&quot; =&amp;gt; &quot;102&quot;, &quot;sex&quot; =&amp;gt; &quot;男&quot;, &quot;job&quot; =&amp;gt; &quot;开发工程师&quot;),
		array(&quot;name&quot; =&amp;gt; &quot;黄蓉&quot;, &quot;number&quot; =&amp;gt; &quot;103&quot;, &quot;sex&quot; =&amp;gt; &quot;女&quot;, &quot;job&quot; =&amp;gt; &quot;产品经理&quot;)
	);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是php定义多维数组的方式，可以包含键值的方式，定义了三名员工，名字是洪七，郭靖，黄蓉，编号性别职位都在多维数组中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;判断如果是get请求，则进行搜索；如果是POST请求，则进行新建&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;GET&quot;) {
	search();   //搜索员工函数
} elseif ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;){
	create();   //新建员工函数
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$_SERVER&lt;/code&gt;是一个超全局变量，在一个脚本的全部作用域中都可用，不用使用global关键字
&lt;code&gt;$_SERVER[&quot;REQUEST_METHOD&quot;]&lt;/code&gt;返回访问页面使用的请求方法&lt;/p&gt;

&lt;p&gt;php有个很奇怪的地方，就是我们设置的全局变量，比如说&lt;code&gt;$set=1&lt;/code&gt;他要是在函数中使用，还必须要加上一个&lt;code&gt;global&lt;/code&gt;的关键字，就是说他不能直接在函数中去使用，在函数中使用需要加上&lt;code&gt;global $set&lt;/code&gt;。&lt;code&gt;global&lt;/code&gt; 关键词用于访问函数内的全局变量&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;搜索员工函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//通过员工编号搜索员工
function search(){
	//检查是否有员工编号的参数
	//isset检测变量是否设置；empty判断值为否为空
	//超全局变量 $_GET 和 $_POST 用于收集表单数据
	if (!isset($_GET[&quot;number&quot;]) || empty($_GET[&quot;number&quot;])) {
		echo &quot;参数错误&quot;;
		return;
	}
	//函数之外声明的变量拥有 Global 作用域，只能在函数以外进行访问。
	//global 关键词用于访问函数内的全局变量
	global $staff;
	//获取number参数
	$number = $_GET[&quot;number&quot;];
	$result = &quot;没有找到员工。&quot;;

	//遍历$staff多维数组，查找key值为number的员工是否存在，如果存在，则修改返回结果
	foreach ($staff as $value) {
		if ($value[&quot;number&quot;] == $number) {
			$result = &quot;找到员工：员工编号：&quot; . $value[&quot;number&quot;] . &quot;，员工姓名：&quot; . $value[&quot;name&quot;] .
			                  &quot;，员工性别：&quot; . $value[&quot;sex&quot;] . &quot;，员工职位：&quot; . $value[&quot;job&quot;];
			break;
		}
	}
    echo $result;   //输出$result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;新建员工函数&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//创建员工
function create(){
	//判断信息是否填写完全
	if (!isset($_POST[&quot;name&quot;]) || empty($_POST[&quot;name&quot;])
		|| !isset($_POST[&quot;number&quot;]) || empty($_POST[&quot;number&quot;])
		|| !isset($_POST[&quot;sex&quot;]) || empty($_POST[&quot;sex&quot;])
		|| !isset($_POST[&quot;job&quot;]) || empty($_POST[&quot;job&quot;])) {
		echo &quot;参数错误，员工信息填写不全&quot;;
		return;
	}
	//TODO: 获取POST表单数据并保存到数据库

	//提示保存成功
	echo &quot;员工：&quot; . $_POST[&quot;name&quot;] . &quot; 信息保存成功！&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;php&quot;&gt;PHP服务端代码测试&lt;/h4&gt;

&lt;p&gt;PHP服务端代码测试 是在没有客户端的情况下对服务端的一些请求进行测试。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;Fiddler&lt;/code&gt;工具来进行测试&lt;/p&gt;

&lt;p&gt;这个工具非常好用，他可以监听整个电脑所有发出的HTTP请求，可以监听传入的值和响应的值。它还可以去模拟。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;打开软件右框上部点击composer按钮，&lt;/p&gt;

&lt;p&gt;填写要测试的服务端页面地址&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-148fb03f8ad377c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GIT请求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击执行&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-1067020176e8bcb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后查看左侧记录打开&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-7a66b27c39942dcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就测试成功了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;POST请求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-1b3cf2c77e739d9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;POST请求的时候在请求地址栏下面加上&lt;code&gt;Content-type: application/x-www-form-urlencoded&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-229c0cb8d5792d8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样就测试成功了&lt;/p&gt;

&lt;p&gt;在日常开发中，有时候后台做好后，总是等待或依赖前台完成后才可以去调试，其实完全没有必要，我们只需要约定好接口，发送的报文，和返回的报文，通过Fiddler或者类似的工具，直接可以进行调试。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;客户端实现&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;

	&amp;lt;h1&amp;gt;员工查询&amp;lt;/h1&amp;gt;

	&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
	&amp;lt;input type=&quot;text&quot; id=&quot;keyword&quot; /&amp;gt;
	&amp;lt;button id=&quot;search&quot;&amp;gt;查询&amp;lt;/button&amp;gt;
	&amp;lt;p id=&quot;searchResult&quot;&amp;gt;&amp;lt;/p&amp;gt;

	&amp;lt;h1&amp;gt;员工新建&amp;lt;/h1&amp;gt;
	&amp;lt;label&amp;gt;请输入员工姓名：&amp;lt;/label&amp;gt;
	&amp;lt;input type=&quot;text&quot; id=&quot;staffName&quot; /&amp;gt;&amp;lt;br&amp;gt;
	&amp;lt;label&amp;gt;请输入员工编号：&amp;lt;/label&amp;gt;
	&amp;lt;input type=&quot;text&quot; id=&quot;staffNumber&quot; /&amp;gt;&amp;lt;br&amp;gt;
	&amp;lt;label&amp;gt;请选择员工性别：&amp;lt;/label&amp;gt;
	&amp;lt;select id=&quot;staffSex&quot;&amp;gt;
	&amp;lt;option&amp;gt;女&amp;lt;/option&amp;gt;
	&amp;lt;option&amp;gt;男&amp;lt;/option&amp;gt;
	&amp;lt;/select&amp;gt;&amp;lt;br&amp;gt;
	&amp;lt;label&amp;gt;请输入员工职位：&amp;lt;/label&amp;gt;
	&amp;lt;input type=&quot;text&quot; id=&quot;staffJob&quot; /&amp;gt;&amp;lt;br&amp;gt;
	&amp;lt;button id=&quot;save&quot;&amp;gt;保存&amp;lt;/button&amp;gt;
	&amp;lt;p id=&quot;createResult&quot;&amp;gt;&amp;lt;/p&amp;gt;

	&amp;lt;script&amp;gt;
		document.getElementById(&quot;search&quot;).onclick = function() {
			var request = new XMLHttpRequest();
			request.open(&quot;GET&quot;, &quot;server.php?number=&quot; + document.getElementById(&quot;keyword&quot;).value);
			request.send();
			request.onreadystatechange = function() {
				if (request.readyState === 4) {
					if (request.status === 200) {
						document.getElementById(&quot;searchResult&quot;).innerHTML = request.responseText;
					} else {
						alert(&quot;发生错误：&quot; + request.status);
					}
				}
			}
		}

		document.getElementById(&quot;save&quot;).onclick = function() {
			var request = new XMLHttpRequest();
			request.open(&quot;POST&quot;, &quot;server.php&quot;);
			var data = &quot;name=&quot; + document.getElementById(&quot;staffName&quot;).value + &quot;&amp;amp;number=&quot; + document.getElementById(&quot;staffNumber&quot;).value + &quot;&amp;amp;sex=&quot; + document.getElementById(&quot;staffSex&quot;).value + &quot;&amp;amp;job=&quot; + document.getElementById(&quot;staffJob&quot;).value;
			request.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);
			request.send(data);
			request.onreadystatechange = function() {
				if (request.readyState === 4) {
					if (request.status === 200) {
						document.getElementById(&quot;createResult&quot;).innerHTML = request.responseText;
					} else {
						alert(&quot;发生错误：&quot; + request.status);
					}
				}
			}
		}
	&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例源码和使用到的安装包可下载&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 12:59:44 +0800</pubDate>
        <link>http://www.huanghanlian.com/javascript/2016/12/20/js-ajax2.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/javascript/2016/12/20/js-ajax2.html</guid>
        
        <category>Ajax</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>Ajax全接触(一)基础理论</title>
        <description>&lt;p&gt;什么是同步? 客户端要发起请求，服务器端要去处理，而且去响应，这时候客户端完全是等待，等待服务器端的处理和响应，当服务器端处理响应后客户端会重新载入页面。这时候如果你有错误，那么只能再次发起请求，再次等待。同步的事件会让人疯狂。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;同步和异步&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;什么是同步&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-b6b3af70fc67c9a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;客户端要发起请求，服务器端要去处理，而且去响应，这时候客户端完全是等待，等待服务器端的处理和响应，当服务器端处理响应后客户端会重新载入页面。这时候如果你有错误，那么只能再次发起请求，再次等待。同步的事件会让人疯狂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么是异步&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-0cae80f727d40a6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当你填写表单数据时，页面当时就把数据发送到服务器，也就是页面发送了个请求，服务器去做处理和响应，得到你的数据不符合要求，他会把响应结果，发给页面，但是在这个过程中，你还是可以依旧去填写，表单其他内容，这时候服务器告诉你有填写错误的地方，在页面上的表现，只是把你填写错误的旁边标上一行字，并没有刷新你的页面，这样在填写表单时，所有的错误信息都会显示在页面，你可以实时的更正，这个过程中你不会有整个页面的刷新，也不会有整个页面的提交和等待，当你最后点击提交一切都可以搞定了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;怎么实现Ajax技术呢？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;运用HTML和CSS来实现页面，表达信息；&lt;/li&gt;
  &lt;li&gt;运用XMLHttpRequest对象和web服务器进行数据的异步交换；&lt;/li&gt;
  &lt;li&gt;运用JavaScript操作DOM，实现动态局部刷新；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;ajax-xmlhttprequest&quot;&gt;Ajax-XMLHttpRequest对象创建&lt;/h4&gt;

&lt;p&gt;目前浏览器都支持标准的XHR对象，也支持标准的构造函数。&lt;/p&gt;

&lt;p&gt;但是在IE5和IE6浏览器中，是不支持&lt;code&gt;var request=new XMLHttpRequest();&lt;/code&gt;因为那时候&lt;code&gt;XHR&lt;/code&gt;还未定义。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何兼容IE5和IE6甚至更早的版本？&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var request;
if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
	request = new XMLHttpRequest();
} else { // code for IE6, IE5
	request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只需要判断下，如果有XHR定义，我们就使用标准的构造函数，我们直接  &lt;code&gt;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;h4 id=&quot;ajax-http&quot;&gt;Ajax-HTTP请求&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;什么是HTTP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP是计算机，通过网络进行通信的规则。&lt;/p&gt;

&lt;p&gt;它主要使我们客户，也就是常说的浏览器能够从服务器也就是常说的web服务器，去请求信息和服务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-57f1baa5da1bef94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTP是一种无状态的协议&lt;/p&gt;

&lt;p&gt;无状态指的是不建立持久的连接，也就是说服务端不保留连接的一些相关信息。&lt;/p&gt;

&lt;p&gt;一个客户端，想服务器发送请求，然后web服务器返回响应，接着连接就被关闭了，这个处理过程是没有记忆的。如果后续的处理需要之前传递的一些信息，那么就要重新的传递。这就是经常说HTTP是一种无状态的协议。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;概念介绍–HTTP请求&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个完整的HTTP请求过程，通常有下面7个步骤。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;建立TCP连接；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web浏览器向Web服务器发送请求命令；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web浏览器发送请求头信息；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web服务器做出应答；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web服务器发送应答头信息；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web服务器向浏览器发送数据；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web服务器关闭TCP连接；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个HTTP请求一般由四部分组成&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP请求的方法或动作，比如是GIT还是POST请求；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;正在请求的URL，总得知道请求的地址是什么吧；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请求头，包含一些客户端环境信息，身份验证信息等；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;请求体，也就是请求正文，请求正文中可以包含客户提交的查询字符串信息，表单信息等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-e3b24aa4ea98a261.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GIT请求和POST请求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GIT：一般用于信息获取
使用URL传递参数
对所发送信息的数量也有限制，一般在2000个字符&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;POST：一般用于修改服务器上的资源。
对所发送信息的数量无限制&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP响应&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个HTTP响应一般由三部分组成&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;一个数字和文字组成的状态码，用来显示请求是否成功还是失败；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;响应头，响应头也和请求头一样包含许多有用的信息，例如服务类型，日期时间，内容类型和长度等；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;响应体，也就是响应正文；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-9b1fc81d3595d15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTTP响应状态码介绍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;HTTP响应状态码由3位数字构成，其中首位数字定义了状态码的类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;1XX:1开头，信息类，表示收到web浏览器请求，正在进一步的处理中；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2XX:2开头，成功，表示用户请求被正确接收，理解和处理例如：200 OK；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;3XX:3开头，重定向，表示请求没有成功，客户必须采取进一步的动作；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;4XX:4开头，客户端错误，表示客户端提交的请求有错误，例如：404 NOT ;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Found，意味着请求中所引用的文档不存在；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;5XX:5开头，服务器错误，表示服务器不能完成对请求的处理：如 500;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ajax-xmlhttprequest-1&quot;&gt;Ajax-XMLHttpRequest发送请求&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象的方法&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;open(&lt;em&gt;method&lt;/em&gt;,&lt;em&gt;url&lt;/em&gt;,&lt;em&gt;async&lt;/em&gt;)&lt;/td&gt;
      &lt;td&gt;规定请求的类型、URL 以及是否异步处理请求。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;em&gt;method&lt;/em&gt;：请求的类型；GET 或 POST&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;em&gt;url&lt;/em&gt;：文件在服务器上的位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;em&gt;async&lt;/em&gt;：true（异步）或 false（同步）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;send(&lt;em&gt;string&lt;/em&gt;)&lt;/td&gt;
      &lt;td&gt;将请求发送到服务器。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;em&gt;string&lt;/em&gt;：仅用于 POST 请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;GET 请求：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request.open(&quot;GET&quot;,&quot;gte.php&quot;,true);
request.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;POST 请求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request.open(&quot;POST&quot;,&quot;post.php&quot;,true);
request.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;request.open(&quot;POST&quot;,&quot;create.php&quot;,true);
request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
request.send(&quot;name=黄&amp;amp;sex=男&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;setRequestHeader(&lt;em&gt;header&lt;/em&gt;,&lt;em&gt;value&lt;/em&gt;)&lt;/td&gt;
      &lt;td&gt;向请求添加 HTTP 头。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;em&gt;header&lt;/em&gt;: 规定头的名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;&lt;em&gt;value&lt;/em&gt;: 规定头的值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);&lt;/code&gt;
这个方法其实要设置HTTP的头信息，告诉web服务器我们要发送一个表单，
需要注意的是&lt;code&gt;request.setRequestHeader&lt;/code&gt;方法要写在&lt;code&gt;request.open&lt;/code&gt;和&lt;code&gt; request.send&lt;/code&gt;中间，否则将会抛出异常。&lt;/p&gt;

&lt;h4 id=&quot;ajax-xmlhttprequest-2&quot;&gt;Ajax-XMLHttpRequest取得响应&lt;/h4&gt;

&lt;p&gt;获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;responseText&lt;/td&gt;
      &lt;td&gt;获得字符串形式的响应数据。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;responseXML&lt;/td&gt;
      &lt;td&gt;获得 XML 形式的响应数据。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;status和statueText&lt;/td&gt;
      &lt;td&gt;以数字和文本形式返回HTTP状态码。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gitAllResponseHeader()&lt;/td&gt;
      &lt;td&gt;获取所有的响应报头。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;gieResponseHeader( parameter )&lt;/td&gt;
      &lt;td&gt;查询响应的某个字段的值。 parameter 要查询的字段&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;onreadystatechange 事件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当请求被发送到服务器时，我们需要执行一些基于响应的任务。&lt;/p&gt;

&lt;p&gt;每当 readyState 改变时，就会触发 onreadystatechange 事件。&lt;/p&gt;

&lt;p&gt;readyState 属性存有 XMLHttpRequest 的状态信息。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;onreadystatechange&lt;/td&gt;
      &lt;td&gt;存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;readyState&lt;/td&gt;
      &lt;td&gt;存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;0: 请求未初始化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;1: 服务器连接已建立&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;2: 请求已接收&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;3: 请求处理中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;4: 请求已完成，且响应已就绪&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;status&lt;/td&gt;
      &lt;td&gt;200: “OK”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;404: 未找到页面&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code&gt;function but() {
	var request;
	if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
		request = new XMLHttpRequest();
	} else { // code for IE6, IE5
		request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
	}
	request.onreadystatechange = function() {
		if (request.readyState === 4 &amp;amp;&amp;amp; request.status === 200) {  //响应完成且请求成功
			//做一些事情  request.responseText;
		}
	}
	request.open(&quot;GET&quot;, &quot;gte.php&quot;, true);
	request.send();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;总结下Ajax使用的步骤&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;第一步&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;new一个XHM对象&lt;code&gt;new XMLHttpRequest();&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;兼容写法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	var request;
	if (window.XMLHttpRequest) { // code for IE7+, Firefox, Chrome, Opera, Safari
		request = new XMLHttpRequest();
	} else { // code for IE6, IE5
		request = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;第二步&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;调用&lt;code&gt;open&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	request.open(&quot;GET&quot;, &quot;gte.php&quot;, true);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;第三步&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;将请求发送到服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	request.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;第四步&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对过程进行监听来知道服务器是否正确的做出了响应，接着就可以做一些事情&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	request.onreadystatechange = function() {
		if (request.readyState === 4 &amp;amp;&amp;amp; request.status === 200) {  //响应完成且请求成功
			//做一些事情  request.responseText;
		}
	}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 20 Dec 2016 12:59:07 +0800</pubDate>
        <link>http://www.huanghanlian.com/javascript/2016/12/20/js-ajax.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/javascript/2016/12/20/js-ajax.html</guid>
        
        <category>Ajax</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>JavaScript 精粹 基础 进阶(9)OOP面向对象编程(下)</title>
        <description>&lt;p&gt;我们怎么去模拟重载，在javasceipr中我们可以通过参数的类型区别或者数量的区别，来去让同样一个函数名字，可以根据不同的参数列表的情况来去调用相应的函数。&lt;/p&gt;

&lt;p&gt;javascript中函数类型是不确定的，并且参数的个数也是可以任意的，那么我们可以通过判断实际传入的参数的个数，来去做一个模拟的重载，&lt;/p&gt;

&lt;h3 id=&quot;oop&quot;&gt;OOP(模拟重载、链式调用、模块化)&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;模拟重载&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function person() {
	var args = arguments;
	if (typeof args[0] === &#39;object&#39; &amp;amp;&amp;amp; args[0]) {
		if (args[0].name) {
			this.name = args[0].name;
		}
		if (args[0].age) {
			this.age = args[0].age;
		}
	} else {
		if (args[0]) {
			this.name = args[0];
		}
		if (args[1]) {
			this.age = args[1];
		}
	}
};
person.prototype.toString = function() {
	return &quot;姓名:&quot; + this.name + &quot;年龄:&quot; + this.age
}


var peng = new person({
	name: &quot;继小鹏&quot;,
	age: 23
});
console.log(peng.toString()); //姓名:继小鹏年龄:23

var peng1 = new person(&quot;是你&quot;, 23);
console.log(peng1.toString()); //姓名:是你年龄:23
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;调用子类方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;例子1&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
    Object.create = function(proto) {
        function F() {};
        F.prototype = proto;
        return new F();
    };
}

function person(name) {//基类
	this.name=name;
}
person.prototype.init=function(){
	console.log(&quot;你好&quot;+this.name)
}

function student(name,classname){   //学生类
	this.classname=classname;
	person.call(this,name);
}

student.prototype = Object.create(person.prototype);
student.prototype.constructor = student;


student.prototype.init=function(){
	console.log(&quot;你好s&quot;+this.name)
}




var peng=new student(&quot;继小鹏&quot;,&quot;class2&quot;);
console.log(peng);
peng.init();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;例子2子类调用基类方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function person(name) {//基类
	this.name=name;
}

function student(name,classname){   //学生类
	this.classname=classname;
	person.call(this,name);
}

person.prototype.init=function(){
	console.log(this.name)
}

student.prototype.init=function(){
	person.prototype.init.apply(this,arguments);
}

var peng=new student(&quot;继小鹏&quot;,&quot;class2&quot;);
console.log(peng);
peng.init();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;链式调用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function classman() {}
classman.prototype.addClass = function(str) {
	console.log(&#39;calss&#39; + str + &#39;added&#39;);
	return this;
}
var mang = new classman();
mang.addClass(&#39;classA&#39;).addClass(&#39;classB&#39;).addClass(&#39;classC&#39;)

// calssclassAadded
// calssclassBadded
// calssclassCadded
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用jq的时候$(“#id”).addClass(‘df’)
选择器做些操作后在继续addClass(‘df’)还可以再做动作一层层链式去调用。&lt;/p&gt;

&lt;p&gt;例子解释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function classman() {}   //现定义一个构造器classman
classman.prototype.addClass = function(str) {   //给classman构造器prototype添加addClass属性方法
	console.log(&#39;calss&#39; + str + &#39;added&#39;);   //输出表示添加一个class
	return this;  //return this表示返回classman的实例因为返回了实例那么紧接着后面不需要加mang.addClass(&#39;classA&#39;)直接后面加.addClass(&#39;classB&#39;).addClass(&#39;classB&#39;)就可以，每次执行完都会返回实例
}
var mang = new classman();
mang.addClass(&#39;classA&#39;).addClass(&#39;classB&#39;).addClass(&#39;classC&#39;)

// calssclassAadded
// calssclassBadded
// calssclassCadded
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;抽象类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Detectorlse() {
	throw new Error(&quot;Abstract class can not be invoked directly!&quot;);
}
Detectorlse.detect = function() {
	console.log(&#39;Detcetion starting...&#39;);
}
Detectorlse.stop = function() {
	console.log(&#39;Detector stopped&#39;);
}
Detectorlse.init = function() {
	throw new Error(&quot;Error&quot;);
}

function linkDetector() {};
linkDetector.prototype = Object.create(Detectorlse.prototype)
linkDetector.prototype.constructor = linkDetector;

//...add methods to LinkDetector...
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;defineProperty(ES5)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(name) {
	Object.defineProperty(this, &#39;name&#39;, {
		value: name,
		enumerable: true
	});
};
Object.defineProperty(Person, &#39;arms_num&#39;, {
	value: 2,
	enumerable: true
});
Object.seal(Person.prototype);
Object.seal(Person);

function student(name, classname) {
	this.classname = classname;
	Person.call(this, name);
};
student.prototype = Object.create(Person.prototype);
student.prototype.constructor = student;

var peng = new Person(&#39;继小鹏&#39;);
console.log(peng);

var han = new student(&quot;汗&quot;, &quot;class2&quot;);
console.log(han);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;模块化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;定义简单模块化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var moduleA;
moduleA=function(){
	var prop=1;
	function func(){};
	return {
		func:func,
		prop:prop
	}
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义简单模块化2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var moduleA;
moduleA = new function() {
	var prop = 1;

	function func() {};
	this.func = func;
	this.prop = prop;
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;实践（探测器）&lt;/h3&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 11:55:03 +0800</pubDate>
        <link>http://www.huanghanlian.com/javascript/2016/12/20/javascript-jinjie9.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/javascript/2016/12/20/javascript-jinjie9.html</guid>
        
        <category>__proto__</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>JavaScript 精粹 基础 进阶(8)OOP面向对象编程(上)</title>
        <description>&lt;p&gt;面向对象编程，oop并不是针对与javascript，很多语言都实现了oop这样一个编程发法论，比如说java，c++，都是实现了oop的语言。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;概念与继承&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;概念&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;面向对象程序设计(Object-oriented programming OOP)是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例，它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性，灵活性和扩展性。       来自于 —-维基百科&lt;/p&gt;

&lt;p&gt;OOP重点的一些特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;继承&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;封装&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;抽象&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;基于原型的继承&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
	this.y = 2;
};
Foo.prototype.x = 1;
console.log(Foo.prototype); //object
var obj1 = new Foo();
console.log(obj1.y); //2
console.log(obj1.x); //1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数声明创建&lt;code&gt;Foo()&lt;/code&gt;函数，这个函数就会有一个内置的&lt;code&gt;Foo.prototype&lt;/code&gt;，并且这个属性是对象，并且是预设的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
	this.y = 2;
};

console.log(Foo.prototype); //object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-81f6d095f48ed6dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
	this.y = 2;
};
Foo.prototype.x = 1;
console.log(Foo.prototype); //object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-91e78a44dcce6ce6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后我们把&lt;code&gt;Foo.prototype&lt;/code&gt;对象增加一个属性&lt;code&gt;x&lt;/code&gt;并且赋值为1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
	this.y = 2;
};
Foo.prototype.x = 1;
console.log(Foo.prototype); //object
var obj1 = new Foo();
console.log(obj1.y); //2
console.log(obj1.x); //1 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用&lt;code&gt;new&lt;/code&gt;操作符&lt;code&gt;new Foo();&lt;/code&gt;来创建一个&lt;code&gt;Foo();&lt;/code&gt;的实例，叫obj1，&lt;/p&gt;

&lt;p&gt;当时用&lt;code&gt;new&lt;/code&gt;去调用函数的时候，那么构造器也就是说这样一个函数就会作为一个构造器来使用，并且this会指向一个对象，而对象的原型会指向构造器的&lt;code&gt;Foo.prototype&lt;/code&gt;属性。obj1实际上会成为Foo构造器中的this，最后会作为返回值，并且在构造器里面调用的时候会把y赋值为2，并且obj1的原型，也就是他的proto会指向Foo.prototype内置属性，最后可以看到obj.y会返回2，obj.x会返回1，y是这个对象上的直接量，而x是原型链上的，也就是Foo.prototype的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {
	this.y = 2;
};
Foo.prototype.x = 1;
console.log(Foo.prototype);
var obj1 = new Foo();

console.log(obj1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-568a72e297d75aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;prototype属性与原型&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Foo() {};
console.log(Foo.prototype);
Foo.prototype.x=1;
var obj=new Foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-f788c71f7d0e532f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用函数声明去中创建一个函数的时候，这个函数就会有一个&lt;code&gt;prototype&lt;/code&gt;属性，并且他默认会有两个属性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一个是&lt;code&gt;constructor:Foo&lt;/code&gt;constructor属性会指向它本身Foo。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另外一个属性是&lt;code&gt;__proto__&lt;/code&gt;，&lt;code&gt;__proto__&lt;/code&gt;是&lt;code&gt;Foo.prototype&lt;/code&gt;的原型，那么他的原型会指向&lt;code&gt;Object.prototype&lt;/code&gt;也就是说一般的对象比如用花括号括起来的对象字面量，他也会有&lt;code&gt;__proto__&lt;/code&gt;他会指向&lt;code&gt;Object.prototype&lt;/code&gt;因此&lt;code&gt;Object.prototype&lt;/code&gt;上面的一些方法比如说&lt;code&gt;toString&lt;/code&gt;，&lt;code&gt;valueOf&lt;/code&gt;才会被每一个一般的对象所使用，&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;x:1&lt;/code&gt;这个是我通过赋值语句增加的。&lt;/p&gt;

&lt;p&gt;**这句是Foo.prototype的结构  **&lt;/p&gt;

&lt;p&gt;也就是说，这里面有一个&lt;code&gt;Foo&lt;/code&gt;函数，这个&lt;code&gt;Foo&lt;/code&gt;函数呢会有一个&lt;code&gt;prototype&lt;/code&gt;的对象属性，他的作用呢就是在当使用&lt;code&gt;new Foo()&lt;/code&gt;去构造Foo的实例的时候，那么构造器的&lt;code&gt;prototype&lt;/code&gt;的属性，会用作&lt;code&gt;new&lt;/code&gt;出来的这些对象的原型。&lt;/p&gt;

&lt;p&gt;所以要搞清楚&lt;code&gt;prototype&lt;/code&gt;和原型是两回事。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;prototype&lt;/code&gt;是函数对象上的预设的对象属性，而原型呢是我们对象上的一个原型，原型通常都是他的构造器的&lt;code&gt;prototype&lt;/code&gt;属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现class继承另外一个class&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, age) {
	this.name = name;
	this.age = age;
};

Person.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new&quot;);
};

Person.prototype.legs_num = 2;
Person.prototype.arms_num = 2;
Person.prototype.walk = function() {
	console.log(this.name + &quot;is walking...&quot;);
};

function Student(name, age, className) {
	Person.call(this, name, age);
	this.className = className;
};
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;


Student.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new,and form&quot; + this.className + &quot;.&quot;);
};

Student.prototype.learn = function(subject) {
	console.log(this.name + &#39;is learing&#39; + subject + &#39;at&#39; + this.className + &#39;.&#39;);
};

console.log(Student.prototype);

var t = new Student(&quot;黄继鹏&quot;, 23, &quot;class2&quot;);
t.hi();
console.log(t.legs_num);
t.walk();
t.learn(&#39;math&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一个函数Person，人的意思意思是说只要人类的class。  在这个构造函数里面，通过&lt;code&gt;this.name = name;&lt;/code&gt;和&lt;code&gt;this.age = age;&lt;/code&gt;去做一个赋值，如何Person作为函数直接去调用的话，那么这里的this会指向全局对象，在浏览器里就会指向window，使用new去调用Person函数的时候，this会指向一个原型为Person.prototype的一个空对象，然后通过this.name去给这个空对象赋值，最后这里没有写返回值，使用new会this会作为返回值。&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;Person.prototype.hi&lt;/code&gt;来创建所有Person实例共享的方法。&lt;/p&gt;

&lt;p&gt;再创建Student函数，学生这样一个class，那么学生是也是人，他是可以继承人的，每一个学生也是人，并且学生会有他的班级名称或者一些其他的功能方法，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Student(name, age, className) {
	Person.call(this, name, age);
	this.className = className;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建Student函数，这里多传了一个className参数，在Student函数也算是子类里先调用下父类，Person.call(this, name, age);然后把this作为Person里面的this再把name和age传进去，注意这里的this在new被实例的时候会是这个实例的返回值也就是直接量，&lt;/p&gt;

&lt;p&gt;&lt;code&gt;this.className = className;&lt;/code&gt;并且把Student的实例做好赋值，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;把Student.prototype能继承Person.prototype的一些方法&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Student.prototype = Object.create(Person.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用这样一个方法去拿到&lt;code&gt;Person.prototype&lt;/code&gt;对象作为原型的值，这样&lt;code&gt;Student.prototype&lt;/code&gt;原型就会有&lt;code&gt;Person.prototype&lt;/code&gt;的值了。&lt;/p&gt;

&lt;p&gt;如果去掉&lt;code&gt;Object.create()&lt;/code&gt;的话。人有一些方法，但是学生也有自己的一些方法，&lt;code&gt;Student.prototype = Person.prototype;&lt;/code&gt;，&lt;code&gt;Person.prototype;&lt;/code&gt;赋值给&lt;code&gt;Student.prototype&lt;/code&gt;的时候，当我想增加学生自己的方法时，比如说&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Student.prototype.learn = function(subject) {
	console.log(this.name + &#39;is learing&#39; + subject + &#39;at&#39; + this.className + &#39;.&#39;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话由于他们指向的是同一个对象，给&lt;code&gt;Student.prototype&lt;/code&gt;增加对象的时候同时也给&lt;code&gt;Person.prototype;&lt;/code&gt;增加了同样的属性，这不是我们想要的。&lt;/p&gt;

&lt;p&gt;所以说通过&lt;code&gt;Student.prototype = Object.create(Person.prototype);&lt;/code&gt;创建了一个空的对象，而这个空对象的原型指向了&lt;code&gt;Person.prototype&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样的话我们既可以在访问&lt;code&gt;Student.prototype&lt;/code&gt;的时候，可以向上查找&lt;code&gt;Person.prototype&lt;/code&gt;同时可以在不影响&lt;code&gt;Person.prototype&lt;/code&gt;的前提下创建一些自己的&lt;code&gt;Student.prototype&lt;/code&gt;上的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Student.prototype.constructor = Student;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每一个&lt;code&gt;prototype&lt;/code&gt;属性对象都会有一个&lt;code&gt;constructor &lt;/code&gt;属性，他的值是指向函数本身，实际上这里面没有太大的用处，因为我们可以任意的去修改，但是为了保证一致性，我们把这个改成&lt;code&gt;Student.prototype.constructor = Student;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;面向对象例子测试&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, age) {
	this.name = name;
	this.age = age;
};

Person.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new&quot;);
};

Person.prototype.legs_num = 2;
Person.prototype.arms_num = 2;
Person.prototype.walk = function() {
	console.log(this.name + &quot;is walking...&quot;);
};

function Student(name, age, className) {
	Person.call(this, name, age);
	this.className = className;
};
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;


Student.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new,and form&quot; + this.className + &quot;.&quot;);
};

Student.prototype.learn = function(subject) {
	console.log(this.name + &#39;is learing&#39; + subject + &#39;at&#39; + this.className + &#39;.&#39;);
};


var t = new Student(&quot;黄继鹏&quot;, 23, &quot;class2&quot;);
var poi=new Person(&quot;李汉&quot;,22);
console.log(poi);
console.log(t);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-43c16c3c2dc86632.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;再谈原型链&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;再谈原型链&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, age) {
	this.name = name;
	this.age = age;
};

Person.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new&quot;);
};

Person.prototype.legs_num = 2;
Person.prototype.arms_num = 2;
Person.prototype.walk = function() {
	console.log(this.name + &quot;is walking...&quot;);
};

function Student(name, age, className) {
	Person.call(this, name, age);
	this.className = className;
};
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;


Student.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new,and form&quot; + this.className + &quot;.&quot;);
};

Student.prototype.learn = function(subject) {
	console.log(this.name + &#39;is learing&#39; + subject + &#39;at&#39; + this.className + &#39;.&#39;);
};

console.log(Student.prototype);

var peng = new Student(&quot;黄继鹏&quot;, 23, &quot;class2&quot;);
peng.hi();
console.log(peng.legs_num);
peng.walk();
peng.learn(&#39;math&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-37d17481b52e9489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dfg.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个图里面说明了上面代码例子的示意图&lt;/p&gt;

&lt;p&gt;通过&lt;code&gt;var peng = new Student(&quot;黄继鹏&quot;, 23, &quot;class2&quot;);&lt;/code&gt;来创建了一个实例&lt;code&gt;peng&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;peng&lt;/code&gt;的实例他的原型我们用&lt;code&gt;__proto__&lt;/code&gt;表示，就会指向构造器&lt;code&gt;Student.prototype&lt;/code&gt;的属性。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Student.prototype&lt;/code&gt;上面有&lt;code&gt;hi&lt;/code&gt;和&lt;code&gt;learn &lt;/code&gt;方法，&lt;code&gt;Student.prototype&lt;/code&gt;是通过&lt;code&gt;Student.prototype = Object.create(Person.prototype);&lt;/code&gt;构造的，所以说&lt;code&gt;Student.prototype&lt;/code&gt;是一个对象，并且的原型指向&lt;code&gt;Person.prototype&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Person.prototype&lt;/code&gt;。也给她设置了很多属性，&lt;code&gt;hi&lt;/code&gt;…等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Person.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new&quot;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Person.prototype.hi&lt;/code&gt;其实是内置的普通对象，内置对象他本身也会有他的原型，他的原型就是&lt;code&gt;Object.prototype&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;也就是因为这样所以说随便一个对象才会有&lt;code&gt;hasOwnProperty&lt;/code&gt;，&lt;code&gt;valueOf&lt;/code&gt;，&lt;code&gt;toString&lt;/code&gt;等一些公共的函数，这些函数都是从&lt;code&gt;Object.prototype&lt;/code&gt;而来的。&lt;/p&gt;

&lt;p&gt;当我们去调用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;peng.hi();&lt;/code&gt;方法的时候，首先看这个对象上本身有没有&lt;code&gt;hi&lt;/code&gt;方法，在本身没有所以会像上查找，差遭到&lt;code&gt;peng&lt;/code&gt;原型也就是&lt;code&gt;Student.prototype&lt;/code&gt;有这样一个函数方法，所以最终调用的是&lt;code&gt;Student.prototype&lt;/code&gt;上面的&lt;code&gt;hi&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;Student.prototype&lt;/code&gt;不去写&lt;code&gt;hi&lt;/code&gt;方法的时候&lt;code&gt;peng.hi();&lt;/code&gt;会去调用&lt;code&gt;Person.prototype.hi&lt;/code&gt;这样一个方法，&lt;/p&gt;

&lt;p&gt;当我们调用&lt;code&gt;peng.walk();&lt;/code&gt;的时候，先找&lt;code&gt;peng&lt;/code&gt;上发现没有，然后&lt;code&gt;Student.prototype&lt;/code&gt;上面，也没有，&lt;code&gt;Person.prototype&lt;/code&gt;有&lt;code&gt;walk&lt;/code&gt;所以最终调用结果是&lt;code&gt;Person.prototype&lt;/code&gt;上面的&lt;code&gt;walk&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;那么我想去调用&lt;code&gt;peng.toString&lt;/code&gt;的时候也是一层一层向上查找。找到&lt;code&gt;Object.prototype&lt;/code&gt;那么最后到&lt;code&gt;null&lt;/code&gt;也就是最根源没有了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于一切的一般对象都会指向&lt;code&gt;Object.prototype&lt;/code&gt;做一个实际的实验&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj={x:1,y:2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如用&lt;code&gt;obj&lt;/code&gt;等于一个花括号空的字面量，给他属性。&lt;/p&gt;

&lt;p&gt;那么我们知道&lt;code&gt;obj&lt;/code&gt;就是一个普通的对象，&lt;code&gt;obj.x就为1&lt;/code&gt;，&lt;/p&gt;

&lt;p&gt;可以通过&lt;code&gt;obj.__proto__&lt;/code&gt;这样的机制可以让你去访问对象的原型&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-b5d9a4c69be98364.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了&lt;code&gt;obj.__proto__&lt;/code&gt;以外，在es5里面提供了一个方法能够返回一个对象的原型，就是&lt;code&gt;Object.getPrototypeOf(obj)&lt;/code&gt;这样一个方法，可以返回对象原型，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-d719db594dfb0459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过三个等号来判断&lt;code&gt;Object.getPrototypeOf(obj)&lt;/code&gt;是不是等于&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-702aed1426ec6170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;返回&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;也就是说我们随便一个对象仔面了也好或者是函数函数内置的&lt;code&gt;prototype&lt;/code&gt;属性然后去判断 他的原型可以看到也是&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-58ffd9189b45da83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也正因为如此所以说我们才可以调用&lt;code&gt;obj.toString()&lt;/code&gt;，&lt;code&gt;obj.valueOf()&lt;/code&gt;
实际上这些方法都是取自&lt;code&gt;Object.prototype&lt;/code&gt;上的，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-4f6ae91520f49f88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;并不是所有对象最终原型链上最终都有&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;比如说我们创建obj2对象，然后用&lt;code&gt;var obj2=Object.create(null)&lt;/code&gt;，&lt;code&gt;obj2.create(null)&lt;/code&gt;的作用是创建空对象，并且这个对象的原型指向这样一个参数，但是这里参数是null，obj2这个时候他的原型就是&lt;code&gt;undefined&lt;/code&gt;，&lt;code&gt;obj2.toString&lt;/code&gt;就是&lt;code&gt;undefined&lt;/code&gt;那么通过&lt;code&gt;Object.create(null)&lt;/code&gt;创建出来的对象，就没有&lt;code&gt;Object.prototype&lt;/code&gt;的一些方法。所以说并不是所有的对象都继承&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;只是一般我们对象字面量或者是函数的&lt;code&gt;prototype&lt;/code&gt;预制的一般的对象上都有&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-dea28a1efdb65a25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;并不是所有的函数对象都有prototype这样一个预制属性的&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function abc() {};
console.log(abc.prototype);
var hh = abc.bind(null);
console.log(hh.prototype);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-622fd9144fe05236.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用es5友谊和&lt;code&gt;bind&lt;/code&gt;函数，&lt;code&gt;bind&lt;/code&gt;函数是用来修改函数在运行时的&lt;code&gt;this&lt;/code&gt;的，&lt;code&gt;bind&lt;/code&gt;函数返回的也是一个函数，但是&lt;code&gt;bind&lt;/code&gt;函数就没有&lt;code&gt;prototype&lt;/code&gt;预设属性。&lt;/p&gt;

&lt;h3 id=&quot;prototype&quot;&gt;prototype属性&lt;/h3&gt;

&lt;p&gt;javascript中的&lt;code&gt;prototype&lt;/code&gt;原型，不像java的class，是一旦写好了以后不太容易去动态改变的，但是javascript中原型实际上也是普通的对象，那么意味着在程序运行的阶段我们也可以动态的给&lt;code&gt;prototype&lt;/code&gt;添加或者删除一些属性，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
};

Person.prototype.hi = function() {
    console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new&quot;);
};

Person.prototype.legs_num = 2;
Person.prototype.arms_num = 2;
Person.prototype.walk = function() {
    console.log(this.name + &quot;is walking...&quot;);
};

function Student(name, age, className) {
    Person.call(this, name, age);
    this.className = className;
};
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;


Student.prototype.hi = function() {
    console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new,and form&quot; + this.className + &quot;.&quot;);
};

Student.prototype.learn = function(subject) {
    console.log(this.name + &#39;is learing&#39; + subject + &#39;at&#39; + this.className + &#39;.&#39;);
};

console.log(Student.prototype);

var peng = new Student(&quot;黄继鹏&quot;, 23, &quot;class2&quot;);
peng.hi();
console.log(peng.legs_num);
peng.walk();
peng.learn(&#39;math&#39;)

Student.prototype.x=101;
console.log(peng.x);//101

Student.prototype={y:2};
console.log(peng.y);//undefined
console.log(peng.x);//101

var nunnly=new Student(&quot;nunnly&quot;, 23, &quot;class3&quot;);

console.log(nunnly.y);//2
console.log(nunnly.x);//undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-d78de6b3ef231ccb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Student.prototype.x=101;
console.log(peng.x);//101

Student.prototype={y:2};
console.log(peng.y);//undefined
console.log(peng.x);//101

var nunnly=new Student(&quot;nunnly&quot;, 23, &quot;class3&quot;);

console.log(nunnly.y);//2
console.log(nunnly.x);//undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如说这里的&lt;code&gt;Student.prototype&lt;/code&gt;同过&lt;code&gt;Student.prototype.x=101;&lt;/code&gt;把&lt;code&gt;huang&lt;/code&gt;的原型动态的添加一个属性&lt;code&gt;x&lt;/code&gt;那么我们发现所有的实例都会受到影响，现在去调用&lt;code&gt;console.log(peng.x);&lt;/code&gt;发现他赋值为101了，&lt;/p&gt;

&lt;p&gt;直接修改Student.prototype={y:2};构造器的属性，把他赋值为一个新的对象，&lt;code&gt;y:2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;有趣的现象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(peng.y);//undefined
console.log(peng.x);//101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们去修改&lt;code&gt;Student.prototype&lt;/code&gt;的时候并不能修改已经实例化的对象，也就是说已经实例化的&lt;code&gt;peng&lt;/code&gt;他的原型已经指向当时的&lt;code&gt;Student.prototype&lt;/code&gt;如果你修改了&lt;code&gt;Student.prototype&lt;/code&gt;的话，并不会影响已经创建的实例，之所以修改的x没有问题，是因为我们修改的是&lt;code&gt;peng&lt;/code&gt;原型的那个对象，&lt;/p&gt;

&lt;p&gt;但是再去用new重新实例化对象，那么会发现x不见了，并且y是新的y值。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;内置构造器的prototype&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;Object.prototype.x = 1;
var obj = {
	y: 3
};
console.log(obj.x); //1
for (var key in obj) {
	console.log(key + &quot;=&quot; + obj[key]); //y=3 x=1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如说我们想让所有的对象他的原型链上都会有x属性会发现所有对象都会有x属性，这样的设置会在for…in的时候会被枚举出来，那么怎么解决这个问题呢&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Object.defineProperty(Object.prototype, &#39;x&#39;, {writable: true,value: 1});
var obj = {
	y: 3
};
console.log(obj.x); //1
for (var key in obj) {
	console.log(key + &quot;=&quot; + obj[key]); //y=3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;value:属性的值给属性赋值&lt;/li&gt;
  &lt;li&gt;writable:如果为false，属性的值就不能被重写。&lt;/li&gt;
  &lt;li&gt;get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。&lt;/li&gt;
  &lt;li&gt;set:一旦目标属性被赋值，就会调回此方法。&lt;/li&gt;
  &lt;li&gt;configurable:如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化。&lt;/li&gt;
  &lt;li&gt;enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;创建对象-new/原型链&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function foo(){}    //定义函数对象 foo
foo.prototype.z = 3;      //函数对象默认带foo.prototype对象属性  这个对象会作为new实例的对象原型  对象添加z属性=3

var obj =new foo();    //用构造器方式构造新的对象
obj.y = 2;    //通过赋值添加2个属性给obj
obj.x = 1;   //通过new去构造这样一个对象他的主要特点是，他的原型会指向构造器的foo.prototype属性

//一般foo.prototype对象他的原型又会指向Object.prototype
//Object.prototype他也会有他的原型最后指向null整个原型链的末端

obj.x; // 1  //访问obj.x发现对象上有x返回1
obj.y; // 2  //访问obj.y发现对象上有x返回2
obj.z; // 3  //obj上没有z并不会停止查找，会去查找他的原型foo.prototype.z返回3
typeof obj.toString; // ‘function&#39;  这是一个函数，toString是Object.prototype上面的每个对象都有
&#39;z&#39; in obj; // true     obj.z是从foo.prototype继承而来的，所以说obj里面有z
obj.hasOwnProperty(&#39;z&#39;); // false   表示z并不是obj直接对象上的，而是对象原型链上的。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-a2fcce85ebf5bb1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;instanceof&quot;&gt;instanceof&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;instanceof&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;instanceof&lt;/code&gt;数据类型判断方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log([1, 2] instanceof Array); //true
console.log(new Object() instanceof Array); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;左边要求是一个对象&lt;code&gt;instanceof&lt;/code&gt;右边要求是一个函数或者说构造器
他会判断右边的构造器的 &lt;code&gt;prototype&lt;/code&gt;的属性是否出现在左边这个对象的原型链上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log([1, 2] instanceof Array); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;[1,2]&lt;/code&gt;这里是数组字面量，数组的字面量他也有他的原型，他的原型就是&lt;code&gt;Array.prototype&lt;/code&gt;所以返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log(new Object() instanceof Array); //false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;new Object()&lt;/code&gt;new一个空对象空对象的原型会指向&lt;code&gt;Object.prototype&lt;/code&gt;。&lt;code&gt;new Object()&lt;/code&gt;的原型链不是&lt;code&gt;Array.prototype&lt;/code&gt;所以返回&lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;console.log([1, 2] instanceof Object); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为数组他的原型是Array.prototype，而Array.prototype的原型就是Object.prototype，所以返回true&lt;/p&gt;

&lt;p&gt;所以说&lt;strong&gt;instanceof&lt;/strong&gt;我们可以判断某一个对象他的原型链上是否有右边这个函数构造器的prototype对象属性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function per() {};

function sor() {};
sor.prototype = new per();
sor.prototype.constructor = sor;

var peng = new sor();
var han = new per();
console.log(peng instanceof sor); //true
console.log(peng instanceof per); //true
console.log(han instanceof sor); //false
console.log(han instanceof per); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实现继承的方式&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;实现继承的方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
	Object.create = function(proto) {
		function F() {};
		F.prototype = proto;
		return new F();
	};
}


function Person(name, age) {
	this.name = name;
	this.age = age;
};

Person.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new&quot;);
};

Person.prototype.legs_num = 2;
Person.prototype.arms_num = 2;
Person.prototype.walk = function() {
	console.log(this.name + &quot;is walking...&quot;);
};

function Student(name, age, className) {
	Person.call(this, name, age);
	this.className = className;
};
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;


Student.prototype.hi = function() {
	console.log(&#39;Hi my name is&#39; + this.name + &quot;,I&#39;m&quot; + this.age + &quot;years old new,and form&quot; + this.className + &quot;.&quot;);
};

Student.prototype.learn = function(subject) {
	console.log(this.name + &#39;is learing&#39; + subject + &#39;at&#39; + this.className + &#39;.&#39;);
};

console.log(Student.prototype);

var t = new Student(&quot;黄继鹏&quot;, 23, &quot;class2&quot;);
t.hi();
console.log(t.legs_num);
t.walk();
t.learn(&#39;math&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Object.create()&lt;/code&gt;也有他的问题，他是es5之后才支持的，但是没有关系在es5之前我们可以写一个模拟的方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
	Object.create = function(proto) {
		function F() {};
		F.prototype = proto;
		return new F();
	};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面我们可以判断下有没有&lt;code&gt;Object.create&lt;/code&gt;如果没有的话，我们可以把他赋值为一个函数，这里会传进来一个参数，写一个临时的空函数，把空函数的prototype属性赋值给想要作为原型的对象，然后返回new F()，会创建一个对象，这个对象的原型指向构造器的prototype，利用这样的规则返回空对象，并且对象原型指向参数也就是要继承的原型。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 11:54:56 +0800</pubDate>
        <link>http://www.huanghanlian.com/javascript/2016/12/20/javascript-jinjie8.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/javascript/2016/12/20/javascript-jinjie8.html</guid>
        
        <category>__proto__</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
      <item>
        <title>JavaScript 精粹 基础 进阶(7)函数和作用域（闭包、作用域）</title>
        <description>&lt;p&gt;闭包在JavaScript 中是一个非常重要的概念。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;闭包例子&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;function outer() {
	var loc = 30;
	return loc;
};
console.log(outer()); //30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;outer&lt;/code&gt;函数是一个函数声明，有一个局部变量&lt;code&gt;loc &lt;/code&gt;赋值为30，返回&lt;code&gt;loc &lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当这个函数调用之后，局部变量就会被释放了，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function outer() {
	var loc = 30;
	return function() {
		return loc;
	};
};
var func = outer();
console.log(func()); //30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个&lt;code&gt;outer&lt;/code&gt;函数有一个&lt;code&gt;loc&lt;/code&gt;的局部变量，返回值是一个匿名函数表达式，在这个函数表达式又返回&lt;code&gt;outer&lt;/code&gt;函数的&lt;code&gt;loc&lt;/code&gt;局部变量，这种情况&lt;code&gt;loc&lt;/code&gt;是不会被释放掉的。&lt;/p&gt;

&lt;p&gt;调用&lt;code&gt;var func = outer();&lt;/code&gt;返回的是一个匿名函数，这个匿名函数里面仍然能够访问到&lt;code&gt;outer()&lt;/code&gt;de 局部变量&lt;code&gt;loc &lt;/code&gt;，当&lt;code&gt;outer()&lt;/code&gt;函数被调用之后，&lt;code&gt;func()&lt;/code&gt;这个函数再次调用的时候任然能访问到它外层&lt;code&gt;outer()&lt;/code&gt;函数的局部变量&lt;code&gt;loc &lt;/code&gt;。
这种情况就是我们通常所说的&lt;strong&gt;闭包&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么闭包的作用是什么呢？在前端编程里，闭包是非常常见的&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;闭包无处不在&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body&amp;gt;
&amp;lt;input type=&quot;button&quot; value=&quot;按钮&quot; id=&quot;but&quot;&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
var but = document.getElementById(&quot;but&quot;);
! function() {
	var loc = 0;
	but.onclick = function() {
		console.log(loc++);
	};
}();
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3877962-d26c006fb9866d89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Paste_Image.png&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&quot;button&quot; value=&quot;按钮&quot; id=&quot;but&quot;&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
var but = document.getElementById(&quot;but&quot;);
! function() {
	var loc = &quot;locc&quot;;
	but.addEventListener(&#39;click&#39;, function() {
		console.log(loc);
	}, false);
}();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如说我们可能有一些自己的局部变量，或者说我们的函数有一些外函数的变量，我们在做点击事件的时候，这个点击事件可能会用到外层的一些局部变量，有了闭包我们可以在数据的传递上更为灵活。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;! function() {
	var loc = &quot;loc&quot;;
	var url = &quot;http://www.huanghanlian.com/&quot;;
	$.ajax({
		url: url,
		success: function() {
			//do sth
			console.log(loc);
		}
	});
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有一个异步的请求，用jq的&lt;code&gt;$.ajax&lt;/code&gt;方法也可以在&lt;code&gt;success&lt;/code&gt;的回调函数中去用到外层具体的一些变量。&lt;/p&gt;

&lt;p&gt;因为闭包的缘故，在最外层匿名函数调用结束后，&lt;code&gt;success&lt;/code&gt;的回调函数仍然可以访问外层的局部变量。&lt;code&gt;loc &lt;/code&gt;，&lt;code&gt;url&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;闭包-常见错误之循环闭包&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;document.body.innerHTML = &quot;&amp;lt;div id=a1&amp;gt;aa&amp;lt;/div&amp;gt;&quot; + &quot;&amp;lt;div id=a2&amp;gt;bb&amp;lt;/div&amp;gt;&quot; + &quot;&amp;lt;div id=a3&amp;gt;cc&amp;lt;/div&amp;gt;&quot; + &quot;&amp;lt;div id=a4&amp;gt;dd&amp;lt;/div&amp;gt;&quot;;
for (var i = 1; i &amp;lt; 4; i++) {
	document.getElementById(&quot;a&quot; + i).addEventListener(&#39;click&#39;, function() {
		console.log(i);//始终都是4
	}, false);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面在网页上面添加三个元素，通过循环来给这三个元素绑定事件，想当点击第一个元素的时候，输出1点击第二个输出2第三个输出3。实现方式是先循环获取元素，给元素增加点击事件，点击事件里面会输出&lt;code&gt;i&lt;/code&gt;的值。&lt;/p&gt;

&lt;p&gt;但是上面的代码始终只会输出4，这其实是闭包的原因，&lt;code&gt;addEventListener(&#39;click&#39;, function() {这里是回调函数}&lt;/code&gt;是回调函数，也就是说当点击时回调函数去做你想做的事情， 当我点击的湿乎乎回调函数回去动态的拿到  &lt;code&gt;i&lt;/code&gt;的值，这个&lt;code&gt;i&lt;/code&gt;的值在整个初始化过程中完成之后实际上&lt;code&gt;i&lt;/code&gt;的值就已经是4了，所以始终输出4。&lt;/p&gt;

&lt;p&gt;如果想想要实现效果就要用到闭包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.body.innerHTML = &quot;&amp;lt;div id=a1&amp;gt;aa&amp;lt;/div&amp;gt;&quot; + &quot;&amp;lt;div id=a2&amp;gt;bb&amp;lt;/div&amp;gt;&quot; + &quot;&amp;lt;div id=a3&amp;gt;cc&amp;lt;/div&amp;gt;&quot;;
for (var i = 1; i &amp;lt; 4; i++) {
	! function(i) {
		document.getElementById(&quot;a&quot; + i).addEventListener(&#39;click&#39;, function() {
			console.log(i);//1,2,3
		}, false);
	}(i);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子里面在每一层循环的时候，用一个匿名函数而且是立即执行的匿名函数给他包装起来，然后将每一次遍历的1.2.3分别的值去传到这个匿名函数里，然后匿名函数接到这个参数&lt;code&gt;i&lt;/code&gt;再放到点击事件中去引用&lt;code&gt;i&lt;/code&gt;当我们每次点击事件输出的值&lt;code&gt;i&lt;/code&gt;就会取每一个闭包环境下的&lt;code&gt;i&lt;/code&gt;。所以这样就能达到效果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;闭包-封装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;闭包还有个好处就是可以封装一些变量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function() {
	var _userId = 23492;
	var _typeId = &#39;item&#39;;
	var expor = {};

	function converter(userId) {
		return +userId;
	};

	expor.getUserId = function() {
		return converter(_userId);
	};

	expor.getTypeId = function() {
		return _typeId;
	};
	window.expor = expor;
}());
console.log(expor.getUserId()); //23492
console.log(expor.getTypeId()); //item
console.log(expor._userId); //undefined
console.log(expor._typeId); //undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如说以上代码，有个立即调用函数，他有自己的函数作用域，在里面定义的局部变量外部是不可以访问到的，最后可以通过&lt;code&gt;window.expor = expor;&lt;/code&gt;这样的方式来去把最终想输出的对象输出出去，那么外部就可以通过&lt;code&gt;expor &lt;/code&gt;对象上提供的方法，就可以访问到函数里面的对象或变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;闭包的概念&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在计算机科学中，闭包(也称词法闭包或函数闭包)是指一个函数或函数的引用，与一个引用环境绑在一起。这个引用环境是一个存储该函数每个非局部变量(也叫自由变量)的表。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;闭包，不同于一般函数，它允许一个函数在立即词法作用域外调用时，仍可访问非本地变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;section-1&quot;&gt;作用域&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;全局，函数，eval  [作用域]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JavaScript中的作用域，实际上是比较简单的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全局作用域&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var a = 10;
console.log(window.a); //10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在最外层声明变量a，这样就声明了全局作用域下的变量a。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (var i = 0; i &amp;lt; 4; i++) {
	console.log(i); //0.1.2.3
}
console.log(i); //4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在全局范围内用for循环里面有个&lt;code&gt;vae i=0&lt;/code&gt;定义了一个变量&lt;code&gt;i&lt;/code&gt;，可能会误解为这个&lt;code&gt;i&lt;/code&gt;只能在这个for循环里面可见，对外不可见，实际上这是错误的理解，JavaScript中是没有块级作用域的，也就是说不管是for循环while 循环里面去定义的变量，实际上和在外面定义的变量，也就是for循环所在的外面去定义变量实际上是没有差别的，所以 &lt;code&gt;i&lt;/code&gt;在外面也能访问到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数作用域&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function() {
	var b = 20;
})();
console.log(b);//test_lt.html:13 Uncaught ReferenceError: b is not defined(…)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面匿名立即执行函数表达式，在执行的时候声明局部变量b，在函数外面是拿不到的。函数有自己独立的作用域。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;eval  作用域&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eval(&quot;var a=1;&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;作用域链&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var le3 = 3;

function out() {
	var le = 1;

	function out2() {
		var le2 = 2;
		console.log(le, le2, le3); //1 2 3
	}
	out2()
}
out();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;out()&lt;/code&gt;函数中有一个内部函数&lt;code&gt;out2()&lt;/code&gt;它里面有一个局部变量&lt;code&gt;le2&lt;/code&gt;，函数&lt;code&gt;out2()&lt;/code&gt;能访问到自己的内部变量&lt;code&gt;le2&lt;/code&gt;，也可以在向上访问&lt;code&gt;le&lt;/code&gt;变量，也就是所谓的闭包，可以访问外层函数的局部变量，对于函数&lt;code&gt;out2()&lt;/code&gt;来讲也叫作它的自由变量，还可以访问最外层的&lt;code&gt;le3 &lt;/code&gt;变量，也就是全局对象，这个作用域手机从内向外都可以访问的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function out() {
	var le = 1;
	var func = new Function(&quot;var p=0;console.log(p);console.log(le)&quot;);
	func();
}
out();
//输出
//0
//Uncaught ReferenceError: le is not defined(…)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果使用&lt;code&gt;new Function&lt;/code&gt;去构造的一个函数，构造器，去调用构造器定义位置所在的变量&lt;code&gt;le&lt;/code&gt;的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;利用函数作用域封装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;(function() {
	//do sth here
	var a, b;
})();

! function() {
	//do sth here
	var a, b;
}();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用函数作用域的特性，我们经常看到很多类库，或者代码最外层如果没有模块化的一些工具的话，会在最外层去写一个&lt;code&gt;function&lt;/code&gt;这样一个匿名函数，这样的好处就是可以把函数内部的变量变成函数的局部变量，而不是全局变量，这样防止大量的全局变量和其他的一些类库或者其他代码引发冲突，&lt;code&gt;! function() {}()&lt;/code&gt;这样的作用其实就是把函数变成函数表达式，而不是函数声明，如果省略掉这个&lt;code&gt;!&lt;/code&gt;叹号的话，那么他会理解为函数声明，会被前置处理掉，那么最后留下一个括号或者你省略名字的话，都会报语法错误。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Dec 2016 11:54:48 +0800</pubDate>
        <link>http://www.huanghanlian.com/javascript/2016/12/20/javascript-jinjie7.html</link>
        <guid isPermaLink="true">http://www.huanghanlian.com/javascript/2016/12/20/javascript-jinjie7.html</guid>
        
        <category>__proto__</category>
        
        
        <category>JavaScript</category>
        
      </item>
    
  </channel>
</rss>
